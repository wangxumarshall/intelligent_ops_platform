<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Scheduler Trace Visualizer</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            background-color: #f8f9fa;
        }

        .metric-card {
            background-color: white;
            border-radius: 0.75rem;
            box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
        }

        #graph-container {
            height: 100vh;
            position: relative;
            cursor: move;
            overflow: hidden;
        }

        svg {
            width: 100%;
            height: 100%;
            display: block;
        }

        .node, .link-group {
            cursor: pointer;
        }

        #tooltip {
            position: absolute;
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 6px 10px;
            border-radius: 4px;
            font-size: 0.85rem;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
        }

        .arrowhead {
            fill: #999;
        }

        .table-container {
            max-height: 100vh;
            overflow-y: auto;
        }

        .compact-table th, .compact-table td {
            padding: 0.3rem 0.5rem;
        }

        .node-highlighted {
            fill: #f59e0b !important;
            r: 10 !important;
            stroke: #b45309 !important;
            stroke-width: 2px !important;
        }

        .node-dimmed {
            fill: #d1d5db !important;
            r: 5 !important;
            opacity: 0.5 !important;
        }

        .link-highlighted {
            stroke: #f59e0b !important;
            stroke-width: 2px !important;
            stroke-opacity: 0.8 !important;
        }

        .link-dimmed {
            stroke: #e5e7eb !important;
            stroke-width: 0.5px !important;
            stroke-opacity: 0.3 !important;
        }

        .task-link {
            cursor: pointer;
            color: #4f46e5;
            text-decoration: underline;
        }

        .task-link:hover {
            color: #1e40af;
        }

        .filter-active {
            background-color: #f3f4f6;
        }

        .highlighted-node-text {
            display: block !important;
            font-weight: bold !important;
            fill: #b45309 !important;
        }

        .depth-level {
            display: inline-block;
            width: 15px;
            height: 15px;
            border-radius: 50%;
            margin-right: 5px;
        }
    </style>
</head>
<body>

    <div class="flex flex-col w-full p-4 md:p-6 lg:p-8 bg-gray-50">
        <h1 class="text-3xl font-bold text-gray-800 mb-6 text-center">RTOS V2X Scheduler Trace Graph Visualizer</h1>
        <div class="metric-card p-3 mb-4">
             <div class="flex flex-wrap items-center gap-x-4 gap-y-2">
                 <div class="flex items-center">
                    <input type="file" id="fileInput" accept=".txt,.log" class="block w-full text-sm text-gray-500
                        file:mr-3 file:py-1.5 file:px-3
                        file:rounded-full file:border-0 file:text-sm file:font-semibold
                        file:bg-indigo-50 file:text-indigo-700 hover:file:bg-indigo-100">
                 </div>
                 <div class="flex items-center space-x-4 text-sm">
                    <div class="flex items-baseline space-x-1.5">
                        <span class="font-semibold text-gray-600">仅支持V2X调度轨迹数据格式
                        <a href="https://3ms.huawei.com/next/groups/index.html#/wiki/detail?groupId=3828267&wikiId=6571498" class="text-indigo-600 hover:underline">[思路来源] </a>
                        <a href="https://wiki.huawei.com/domains/12565/wiki/179215/WIKI202501105697774" class="text-indigo-600 hover:underline">[调度数据采集]</a>
                        </span>
                    </div>
                 </div>
                 <button id="analyzeBtn" class="px-5 py-1.5 bg-indigo-600 text-white text-sm font-semibold rounded-lg shadow-md hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-opacity-75">Analyze</button>
                 <button id="resetFilterBtn" class="px-4 py-1.5 bg-gray-200 text-gray-700 text-sm font-medium rounded-lg shadow-sm hover:bg-gray-300 focus:outline-none focus:ring-2 focus:ring-gray-500 focus:ring-opacity-75">
                    <i class="fa fa-refresh mr-1"></i>Reset Filter
                 </button>

                 <div class="h-6 border-l border-gray-300 mx-2"></div>

                 <div class="flex items-center space-x-4 text-sm">
                    <div class="flex items-baseline space-x-1.5">
                        <span class="font-semibold text-gray-600">Nodes:</span>
                        <p id="total-nodes" class="font-bold text-indigo-600">-</p>
                    </div>
                    <div class="flex items-baseline space-x-1.5">
                        <span class="font-semibold text-gray-600">Edges:</span>
                        <p id="total-edges" class="font-bold text-indigo-600">-</p>
                    </div>
                     <div class="flex items-baseline space-x-1.5">
                        <span class="font-semibold text-gray-600">Switches:</span>
                        <p id="total-switches" class="font-bold text-indigo-600">-</p>
                    </div>
                    <div class="flex items-baseline space-x-1.5">
                        <span class="font-semibold text-gray-600">当前显示:</span>
                        <p id="current-nodes" class="font-bold text-green-600">-</p>
                    </div>
                    <div class="flex items-baseline space-x-1.5">
                        <span class="font-semibold text-gray-600">当前边:</span>
                        <p id="current-edges" class="font-bold text-green-600">-</p>
                    </div>
                 </div>

                <div class="h-6 border-l border-gray-300 mx-2"></div>

                 <div id="graph-controls" class="flex flex-wrap items-center space-x-2">
                    <label for="weightThreshold" class="text-sm font-medium text-gray-700 whitespace-nowrap">最小调度次数:</label>
                    <input type="number" id="weightThreshold" value="1" min="1" class="w-20 p-1.5 rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm">
                    
                    <label for="graphDirection" class="text-sm font-medium text-gray-700 whitespace-nowrap ml-2">Direct:</label>
                    <select id="graphDirection" class="p-1.5 rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm">
                        <option value="undirected">无向图</option>
                        <option value="directed">有向图</option>
                    </select>
                    
                    <label for="nodeSearch" class="text-sm font-medium text-gray-700 whitespace-nowrap ml-2">搜索节点:</label>
                    <input type="text" id="nodeSearch" placeholder="输入节点名称" class="w-40 p-1.5 rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm">
                    
                    <div class="flex items-center ml-2">
                        <label for="bfsDepth" class="text-sm font-medium text-gray-700 whitespace-nowrap mr-2">BFS深度:</label>
                        <input type="range" id="bfsDepth" min="1" max="10" value="5" class="w-32 h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                        <span id="bfsDepthValue" class="ml-2 text-sm font-medium">5</span>
                    </div>
                    
                    <div class="flex items-center ml-4">
                        <span class="text-xs font-medium text-gray-600">颜色图例:</span>
                        <div class="flex ml-2">
                            <div class="flex items-center mr-3">
                                <div class="depth-level bg-orange-400"></div>
                                <span class="text-xs text-gray-600">源节点</span>
                            </div>
                            <div class="flex items-center mr-3">
                                <div class="depth-level bg-yellow-400"></div>
                                <span class="text-xs text-gray-600">1级节点</span>
                            </div>
                            <div class="flex items-center">
                                <div class="depth-level bg-green-400"></div>
                                <span class="text-xs text-gray-600">2+级节点</span>
                            </div>
                        </div>
                    </div>
                </div>
             </div>
        </div>

        <div class="flex flex-col lg:flex-row gap-4">
            <div class="metric-card flex-grow lg:w-2/3">
                <div id="graph-container" class="relative">
                    <div id="placeholder" class="text-center text-gray-500 flex items-center justify-center h-full">
                        Please upload your trace data file to begin analysis.
                    </div>
                    <svg id="graph-svg"></svg>
                    <div id="tooltip"></div>
                </div>
            </div>

            <div class="metric-card lg:w-1/4 table-container">
                <h2 class="text-lg font-semibold text-gray-700 mb-2 text-center">Filtered Links Table</h2>
                <div class="overflow-x-auto">
                    <table id="links-table" class="w-full text-xs text-left text-gray-500 compact-table">
                        <thead class="text-xs text-gray-700 uppercase bg-gray-50">
                            <tr>
                                <th scope="col" class="px-3 py-2">Task A</th>
                                <th scope="col" class="px-3 py-2">Task B</th>
                                <th scope="col" class="px-3 py-2 text-right">Switches</th>
                            </tr>
                        </thead>
                        <tbody id="links-table-body">
                            <tr>
                                <td colspan="3" class="px-3 py-2 text-center">Upload a file and adjust threshold to see data.</td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const fileInput = document.getElementById('fileInput');
            const analyzeBtn = document.getElementById('analyzeBtn');
            const resetFilterBtn = document.getElementById('resetFilterBtn');
            const weightThresholdInput = document.getElementById('weightThreshold');
            const graphDirectionSelect = document.getElementById('graphDirection');
            const nodeSearchInput = document.getElementById('nodeSearch');
            const bfsDepthInput = document.getElementById('bfsDepth');
            const bfsDepthValue = document.getElementById('bfsDepthValue');
            const tooltip = d3.select("#tooltip");
            const placeholder = document.getElementById('placeholder');
            const graphControls = document.getElementById('graph-controls');
            const graphContainer = document.getElementById('graph-container');

            const totalNodesEl = document.getElementById('total-nodes');
            const totalEdgesEl = document.getElementById('total-edges');
            const totalSwitchesEl = document.getElementById('total-switches');
            const currentNodesEl = document.getElementById('current-nodes');
            const currentEdgesEl = document.getElementById('current-edges');
            const linksTableBody = document.getElementById('links-table-body');

            let fullGraphData = { nodes: [], links: [] };
            let undirectedGraphData = { nodes: [], links: [] };
            let currentGraphData = { nodes: [], links: [] };
            let simulation;
            let currentHighlightedNode = null;
            let connectedNodes = new Map();
            let connectedLinks = new Set();

            // 阻止图表容器的滚轮事件冒泡到页面
            graphContainer.addEventListener('wheel', (e) => {
                if (e.ctrlKey) {
                    // 如果按住Ctrl键，允许默认缩放行为
                    return;
                }
                // 否则阻止页面滚动
                e.preventDefault();
            }, { passive: false });

            analyzeBtn.addEventListener('click', handleAnalysis);
            resetFilterBtn.addEventListener('click', resetGraphFilter);
            weightThresholdInput.addEventListener('input', () => {
                console.log(`Weight threshold changed to: ${weightThresholdInput.value}`);
                drawGraph();
            });
            graphDirectionSelect.addEventListener('change', () => {
                console.log(`Graph direction changed to: ${graphDirectionSelect.value}`);
                drawGraph();
            });
            nodeSearchInput.addEventListener('input', debounce(() => {
                console.log(`Search term: ${nodeSearchInput.value}`);
                drawGraph();
            }, 300));
            
            bfsDepthInput.addEventListener('input', () => {
                bfsDepthValue.textContent = bfsDepthInput.value;
                console.log(`BFS depth changed to: ${bfsDepthInput.value}`);
                if (currentHighlightedNode) {
                    highlightNodeConnections(currentHighlightedNode);
                }
            });

            function handleAnalysis() {
                const file = fileInput.files[0];
                if (!file) {
                    console.warn('No file selected.');
                    fileInput.focus();
                    return;
                }

                placeholder.textContent = 'Analyzing...';
                placeholder.style.display = 'flex';
                document.getElementById('graph-svg').innerHTML = '';
                linksTableBody.innerHTML = '<tr><td colspan="3" class="px-3 py-2 text-center">Analyzing...</td></tr>';

                if (simulation) simulation.stop();

                const reader = new FileReader();
                reader.onload = (event) => {
                    const text = event.target.result;
                    fullGraphData = parseSchedData(text);
                    console.log('Parsed full graph data:', fullGraphData);
                    if (fullGraphData.nodes.length > 0) {
                        undirectedGraphData = buildUndirectedGraph(fullGraphData);
                        currentGraphData = { ...fullGraphData };
                        console.log('Built undirected graph data:', undirectedGraphData);
                        
                        placeholder.style.display = 'none';
                        updateMetrics(fullGraphData);
                        currentNodesEl.textContent = fullGraphData.nodes.length.toLocaleString();
                        currentEdgesEl.textContent = fullGraphData.links.length.toLocaleString();
                        drawGraph();
                    } else {
                        placeholder.textContent = 'Could not parse data from file. Please check the format.';
                        linksTableBody.innerHTML = '<tr><td colspan="3" class="px-3 py-2 text-center">Could not parse data from file. Please check the format.</td></tr>';
                    }
                };
                reader.onerror = (error) => {
                    placeholder.textContent = 'Error reading file.';
                    console.error('Error reading file:', error);
                };
                reader.readAsText(file);
            }

            function updateMetrics({nodes, links}) {
                totalNodesEl.textContent = nodes.length.toLocaleString();
                totalEdgesEl.textContent = links.length.toLocaleString();
                const totalSwitches = links.reduce((sum, link) => sum + link.weight, 0);
                totalSwitchesEl.textContent = totalSwitches.toLocaleString();
            }

            function parseSchedData(text) {
                const lines = text.split('\n');
                const nodeMap = new Map();
                const linkMap = new Map();
                const regex = /prev_comm=([\S]+)\s+prev_pid=\d+\s+prev_tid=([\S]+)[\s\S]*?==>\s+next_comm=([\S]+)\s+next_tid=([\S]+)/;

                for (const line of lines) {
                    const match = line.match(regex);
                    if (match) {
                        const [, prev_comm, prev_tid, next_comm, next_tid] = match;
                        const sourceId = `${prev_comm}/${prev_tid}`;
                        const targetId = `${next_comm}/${next_tid}`;

                        if (sourceId === targetId) continue;

                        if (!nodeMap.has(sourceId)) nodeMap.set(sourceId, { id: sourceId, comm: prev_comm, pid: prev_tid });
                        if (!nodeMap.has(targetId)) nodeMap.set(targetId, { id: targetId, comm: next_comm, pid: next_tid });

                        const linkKey = `${sourceId}->${targetId}`;

                        if (linkMap.has(linkKey)) {
                            linkMap.get(linkKey).weight++;
                        } else {
                            linkMap.set(linkKey, {
                                source: sourceId,
                                target: targetId,
                                weight: 1
                            });
                        }
                    }
                }

                console.log(`Parsed ${nodeMap.size} nodes and ${linkMap.size} links`);
                return {
                    nodes: Array.from(nodeMap.values()),
                    links: Array.from(linkMap.values())
                };
            }

            function buildUndirectedGraph({nodes, links}) {
                const undirectedLinkMap = new Map();
                
                links.forEach(link => {
                    const nodeIds = [link.source, link.target].sort();
                    const undirectedKey = `${nodeIds[0]}->${nodeIds[1]}`;
                    
                    if (undirectedLinkMap.has(undirectedKey)) {
                        undirectedLinkMap.get(undirectedKey).weight += link.weight;
                    } else {
                        undirectedLinkMap.set(undirectedKey, {
                            source: nodeIds[0],
                            target: nodeIds[1],
                            weight: link.weight,
                            originalLinks: [link]
                        });
                    }
                });
                
                console.log(`Built undirected graph with ${nodes.length} nodes and ${undirectedLinkMap.size} links`);
                return {
                    nodes: [...nodes],
                    links: Array.from(undirectedLinkMap.values())
                };
            }

            function drawGraph() {
                console.log('Drawing graph with current settings...');
                if (!fullGraphData.nodes || fullGraphData.nodes.length === 0) {
                    console.log('No graph data available');
                    return;
                }

                const threshold = +weightThresholdInput.value;
                const isDirected = graphDirectionSelect.value === 'directed';
                const searchTerm = nodeSearchInput.value.trim().toLowerCase();
                
                console.log(`Threshold: ${threshold}, Directed: ${isDirected}, Search: ${searchTerm || 'none'}`);
                
                const baseGraphData = isDirected ? fullGraphData : undirectedGraphData;
                
                let { nodes, links } = baseGraphData;
                
                console.log(`Starting with ${nodes.length} nodes and ${links.length} links`);
                
                if (searchTerm) {
                    const matchedNodes = nodes.filter(node => {
                        const match = node.id.toLowerCase().includes(searchTerm) || 
                            (node.comm && node.comm.toLowerCase().includes(searchTerm)) ||
                            (node.pid && node.pid.toLowerCase().includes(searchTerm));
                        console.log(`Node ${node.id}: ${match ? 'MATCH' : 'NO MATCH'}`);
                        return match;
                    });
                    
                    console.log(`Found ${matchedNodes.length} matched nodes`);
                    
                    if (matchedNodes.length === 0) {
                        console.log('No nodes matched search term');
                        nodes = [];
                        links = [];
                    } else {
                        const matchedNodeIds = new Set(matchedNodes.map(node => node.id));
                        
                        links = links.filter(link => {
                            const match = matchedNodeIds.has(link.source) || matchedNodeIds.has(link.target);
                            console.log(`Link ${link.source} -> ${link.target}: ${match ? 'MATCH' : 'NO MATCH'}`);
                            return match;
                        });
                        
                        const nodesInLinks = new Set([
                            ...links.map(link => link.source),
                            ...links.map(link => link.target)
                        ]);
                        
                        nodes = nodes.filter(node => nodesInLinks.has(node.id));
                        
                        console.log(`Filtered to ${nodes.length} nodes and ${links.length} links after search`);
                    }
                }

                const filteredLinks = links
                    .filter(link => {
                        const match = link.weight >= threshold;
                        console.log(`Link ${link.source} -> ${link.target} (weight ${link.weight}): ${match ? 'PASS' : 'FILTERED'}`);
                        return match;
                    })
                    .sort((a, b) => b.weight - a.weight);

                console.log(`After weight threshold filter: ${filteredLinks.length} links`);
                
                // 调试输出过滤后的边数据
                console.log('Filtered links:', filteredLinks);

                const fullNodeLookup = new Map();
                fullGraphData.nodes.forEach(node => {
                    fullNodeLookup.set(node.id, {
                        id: node.id,
                        comm: node.comm || node.id.split('/')[0],
                        pid: node.pid || node.id.split('/')[1]
                    });
                });

                console.log(`Full node lookup created with ${fullNodeLookup.size} entries`);

                // 更新表格
                linksTableBody.innerHTML = '';

                if (filteredLinks.length === 0) {
                    console.log('No links to display in table');
                    const row = linksTableBody.insertRow();
                    const cell = row.insertCell();
                    cell.colSpan = 3;
                    cell.textContent = 'No links meet the current threshold.';
                    cell.className = 'px-3 py-2 text-center';
                } else {
                    console.log(`Populating table with ${filteredLinks.length} links`);
                    filteredLinks.forEach(link => {
                        // 确保link.source和link.target是字符串ID
                        const sourceId = typeof link.source === 'object' ? link.source.id : link.source;
                        const targetId = typeof link.target === 'object' ? link.target.id : link.target;
                        
                        const sourceNode = fullNodeLookup.get(sourceId);
                        const targetNode = fullNodeLookup.get(targetId);
                        
                        console.log(`Table row: ${sourceId} (${sourceNode ? sourceNode.comm : 'unknown'}) -> ${targetId} (${targetNode ? targetNode.comm : 'unknown'})`);
                        
                        // 额外调试：如果节点未找到，输出更多信息
                        if (!sourceNode) {
                            console.warn(`Source node not found for ID: ${sourceId}`, link);
                        }
                        if (!targetNode) {
                            console.warn(`Target node not found for ID: ${targetId}`, link);
                        }

                        const row = linksTableBody.insertRow();
                        row.className = 'bg-white border-b hover:bg-gray-50 transition-colors';

                        const cellNodeA = row.insertCell();
                        cellNodeA.innerHTML = sourceNode ? `<span class="task-link" data-node-id="${sourceId}">${sourceNode.comm}/${sourceNode.pid}</span>` : sourceId;
                        cellNodeA.className = 'px-3 py-2 font-medium text-gray-900 whitespace-nowrap';

                        const cellNodeB = row.insertCell();
                        cellNodeB.innerHTML = targetNode ? `<span class="task-link" data-node-id="${targetId}">${targetNode.comm}/${targetNode.pid}</span>` : targetId;
                        cellNodeB.className = 'px-3 py-2';

                        const cellSwitches = row.insertCell();
                        cellSwitches.textContent = link.weight;
                        cellSwitches.className = 'px-3 py-2 font-semibold text-indigo-600 text-right';
                    });

                    // 为任务链接添加点击事件
                    document.querySelectorAll('.task-link').forEach(link => {
                        link.addEventListener('click', (e) => {
                            const nodeId = e.currentTarget.getAttribute('data-node-id');
                            highlightNodeConnections(nodeId);
                        });
                    });
                }

                // 图形渲染代码
                const container = document.getElementById('graph-container');
                const svg = d3.select("#graph-svg");

                svg.selectAll("*").remove();

                const width = container.clientWidth;
                const height = container.clientHeight;

                const g = svg.append("g");

                if (isDirected) {
                    svg.append("defs").append("marker")
                        .attr("id", "arrowhead")
                        .attr("viewBox", "0 0 10 10")
                        .attr("refX", 9)
                        .attr("refY", 5)
                        .attr("markerWidth", 6)
                        .attr("markerHeight", 6)
                        .attr("orient", "auto")
                        .append("path")
                        .attr("d", "M 0 0 L 10 5 L 0 10 z")
                        .attr("class", "arrowhead");
                }

                // 确保links数据格式正确
                const formattedLinks = filteredLinks.map(link => ({
                    ...link,
                    source: typeof link.source === 'object' ? link.source.id : link.source,
                    target: typeof link.target === 'object' ? link.target.id : link.target
                }));

                simulation = d3.forceSimulation(nodes)
                    .force("link", d3.forceLink(formattedLinks).id(d => d.id)
                        .strength(d => 0.1 * Math.sqrt(d.weight / (d3.max(formattedLinks, l => l.weight) || 1))))
                    .force("charge", d3.forceManyBody().strength(-400))
                    .force("center", d3.forceCenter(width / 2, height / 2))
                    .force("collide", d3.forceCollide().radius(15));

                const linkGroup = g.append("g")
                    .selectAll("g")
                    .data(formattedLinks)
                    .join("g")
                    .attr("class", "link-group");

                const linkLine = linkGroup.append("line")
                    .attr("stroke", "#999")
                    .attr("stroke-opacity", 0.6)
                    .attr("stroke-width", d => Math.min(Math.sqrt(d.weight), 8) * 0.5 + 0.5);
                
                if (isDirected) {
                    linkLine.attr("marker-end", "url(#arrowhead)");
                }

                linkGroup.append("text")
                    .text(d => d.weight)
                    .attr("font-size", "10px")
                    .attr("font-family", "sans-serif")
                    .attr("fill", "#333")
                    .attr("stroke", "white")
                    .attr("stroke-width", 0.4)
                    .attr("paint-order", "stroke")
                    .style("display", "none")
                    .style("pointer-events", "none");

                linkGroup
                    .on("mouseover", function(event, d) {
                        d3.select(this).select('text').style('display', 'block');
                        tooltip.style("opacity", 1).html(`切换次数: ${d.weight}`);
                    })
                    .on("mousemove", (event) => {
                        tooltip.style("left", (event.pageX + 15) + "px")
                               .style("top", (event.pageY - 28) + "px");
                    })
                    .on("mouseout", function() {
                        d3.select(this).select('text').style('display', 'none');
                        tooltip.style("opacity", 0);
                    });

                const nodeGroup = g.append("g")
                    .selectAll("g")
                    .data(nodes)
                    .join("g")
                    .attr("class", "node");

                nodeGroup.append("circle")
                    .attr("r", 8)
                    .attr("fill", "#4f46e5")
                    .attr("stroke", "#fff")
                    .attr("stroke-width", 1.5);

                nodeGroup.append("text")
                    .text(d => `${d.comm}/${d.pid}`)
                    .attr("x", 12)
                    .attr("y", 4)
                    .attr("font-size", "12px")
                    .attr("font-family", "monospace")
                    .attr("fill", "#333")
                    .style("display", "none")
                    .style("pointer-events", "none");

                nodeGroup.on("mouseover", function(event, d) {
                        d3.select(this).select('text').style('display', 'block');
                        tooltip.style("opacity", 1).html(`任务: ${d.id}`);
                    })
                    .on("mousemove", (event) => {
                        tooltip.style("left", (event.pageX + 15) + "px")
                               .style("top", (event.pageY - 28) + "px");
                    })
                    .on("mouseout", function() {
                        d3.select(this).select('text').style('display', 'none');
                        tooltip.style("opacity", 0);
                    })
                    .on("click", function(event, d) {
                        highlightNodeConnections(d.id);
                    });

                const drag = d3.drag()
                    .on("start", (event, d) => {
                        if (!event.active) simulation.alphaTarget(0.3).restart();
                        d.fx = d.x;
                        d.fy = d.y;
                    })
                    .on("drag", (event, d) => {
                        d.fx = event.x;
                        d.fy = event.y;
                    })
                    .on("end", (event, d) => {
                        if (!event.active) simulation.alphaTarget(0);
                        d.fx = null;
                        d.fy = null;
                    });

                nodeGroup.call(drag);

                const zoom = d3.zoom()
                    .scaleExtent([0.1, 10])
                    .on("zoom", (event) => {
                        g.attr("transform", event.transform);
                    });

                svg.call(zoom);

                simulation.on("tick", () => {
                    linkGroup.select("line")
                        .attr("x1", d => d.source.x)
                        .attr("y1", d => d.source.y)
                        .attr("x2", d => d.target.x)
                        .attr("y2", d => d.target.y);

                    linkGroup.select("text")
                        .attr("x", d => (d.source.x + d.target.x) / 2)
                        .attr("y", d => (d.source.y + d.target.y) / 2);

                    nodeGroup.attr("transform", d => `translate(${d.x},${d.y})`);
                });
                
                console.log('Graph drawing completed');
                
                // 如果有当前高亮节点，重新应用高亮
                if (currentHighlightedNode) {
                    highlightNodeConnections(currentHighlightedNode);
                }
            }

            function highlightNodeConnections(nodeId) {
                console.log(`Highlighting connections for node: ${nodeId} with BFS depth: ${bfsDepthInput.value}`);
                
                // 重置之前的高亮状态
                d3.selectAll('.node circle').classed('node-highlighted', false).classed('node-dimmed', false);
                d3.selectAll('.link-group line').classed('link-highlighted', false).classed('link-dimmed', false);
                d3.selectAll('.node text').classed('highlighted-node-text', false);
                
                // 如果点击同一个节点，取消高亮
                if (currentHighlightedNode === nodeId) {
                    currentHighlightedNode = null;
                    connectedNodes.clear();
                    connectedLinks.clear();
                    document.querySelectorAll('.task-link').forEach(link => {
                        link.classList.remove('font-bold', 'text-indigo-700');
                    });
                    currentNodesEl.textContent = fullGraphData.nodes.length.toLocaleString();
                    currentEdgesEl.textContent = fullGraphData.links.length.toLocaleString();
                    return;
                }
                
                currentHighlightedNode = nodeId;
                connectedNodes.clear();
                connectedLinks.clear();
                
                // 使用广度优先搜索找到所有连通的节点
                const isDirected = graphDirectionSelect.value === 'directed';
                const baseGraphData = isDirected ? fullGraphData : undirectedGraphData;
                const maxDepth = +bfsDepthInput.value;
                
                // BFS初始化
                const queue = [{id: nodeId, depth: 0}];
                connectedNodes.set(nodeId, 0);
                
                // 执行BFS
                while (queue.length > 0) {
                    const {id, depth} = queue.shift();
                    
                    // 如果达到最大深度，不再继续扩展
                    if (depth >= maxDepth) continue;
                    
                    // 查找与当前节点相连的所有节点
                    baseGraphData.links.forEach(link => {
                        if (link.source === id) {
                            const neighborId = link.target;
                            if (!connectedNodes.has(neighborId)) {
                                connectedNodes.set(neighborId, depth + 1);
                                connectedLinks.add(`${link.source}-${link.target}`);
                                queue.push({id: neighborId, depth: depth + 1});
                            } else {
                                connectedLinks.add(`${link.source}-${link.target}`);
                            }
                        } else if (link.target === id) {
                            const neighborId = link.source;
                            if (!connectedNodes.has(neighborId)) {
                                connectedNodes.set(neighborId, depth + 1);
                                connectedLinks.add(`${link.source}-${link.target}`);
                                queue.push({id: neighborId, depth: depth + 1});
                            } else {
                                connectedLinks.add(`${link.source}-${link.target}`);
                            }
                        }
                    });
                }
                
                console.log(`Found ${connectedNodes.size} connected nodes with depth limit ${maxDepth}`);
                
                // 更新节点样式
                d3.selectAll('.node circle').each(function(d) {
                    if (connectedNodes.has(d.id)) {
                        const depth = connectedNodes.get(d.id);
                        let fillColor;
                        
                        // 根据深度设置不同的颜色
                        if (depth === 0) {
                            fillColor = '#f59e0b'; // 源节点
                        } else if (depth === 1) {
                            fillColor = '#eab308'; // 一级节点
                        } else {
                            fillColor = '#22c55e'; // 二级及以上节点
                        }
                        
                        d3.select(this)
                            .attr('fill', fillColor)
                            .classed('node-highlighted', true)
                            .classed('node-dimmed', false);
                            
                        // 显示高亮节点的文本
                        d3.select(this.parentNode).select('text')
                            .classed('highlighted-node-text', true);
                    } else {
                        d3.select(this).classed('node-highlighted', false).classed('node-dimmed', true);
                    }
                });
                
                // 更新边样式
                d3.selectAll('.link-group line').each(function(d) {
                    const linkKey = `${d.source.id}-${d.target.id}`;
                    if (connectedLinks.has(linkKey) || connectedLinks.has(`${d.target.id}-${d.source.id}`)) {
                        d3.select(this).classed('link-highlighted', true).classed('link-dimmed', false);
                    } else {
                        d3.select(this).classed('link-highlighted', false).classed('link-dimmed', true);
                    }
                });
                
                // 更新表格中的高亮
                document.querySelectorAll('.task-link').forEach(link => {
                    if (link.getAttribute('data-node-id') === nodeId) {
                        link.classList.add('font-bold', 'text-indigo-700');
                    } else {
                        link.classList.remove('font-bold', 'text-indigo-700');
                    }
                });
                
                // 更新当前显示的节点数和边数
                currentNodesEl.textContent = connectedNodes.size.toLocaleString();
                currentEdgesEl.textContent = connectedLinks.size.toLocaleString();
            }

            function resetGraphFilter() {
                console.log('Resetting graph filter');
                
                // 重置高亮状态
                d3.selectAll('.node circle').classed('node-highlighted', false).classed('node-dimmed', false);
                d3.selectAll('.link-group line').classed('link-highlighted', false).classed('link-dimmed', false);
                d3.selectAll('.node text').classed('highlighted-node-text', false);
                
                // 重置表格中的高亮
                document.querySelectorAll('.task-link').forEach(link => {
                    link.classList.remove('font-bold', 'text-indigo-700');
                });
                
                // 重置当前高亮节点
                currentHighlightedNode = null;
                connectedNodes.clear();
                connectedLinks.clear();
                
                // 重置当前显示的节点数
                currentNodesEl.textContent = fullGraphData.nodes.length.toLocaleString();
                currentEdgesEl.textContent = fullGraphData.links.length.toLocaleString();
            }

            function debounce(func, delay) {
                let timeout;
                return function() {
                    const context = this;
                    const args = arguments;
                    clearTimeout(timeout);
                    timeout = setTimeout(() => func.apply(context, args), delay);
                };
            }
        });
    </script>
</body>
</html>    
