<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Scheduler Trace Visualizer</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            background-color: #f8f9fa;
        }

        .metric-card {
            background-color: white;
            border-radius: 0.75rem;
            box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
        }

        #graph-container {
            height: 100vh;
            position: relative;
            cursor: move;
            overflow: hidden;
        }

        svg {
            width: 100%;
            height: 100%;
            display: block;
        }

        .node, .link-group {
            cursor: pointer;
        }

        #tooltip {
            position: absolute;
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 6px 10px;
            border-radius: 4px;
            font-size: 0.85rem;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
        }

        .arrowhead {
            fill: #333; /* Changed for better visibility */
        }

        .table-container {
            max-height: 100vh;
            overflow-y: auto;
        }

        .compact-table th, .compact-table td {
            padding: 0.3rem 0.5rem;
        }

        .node-highlighted {
            fill: #f59e0b !important;
            r: 10 !important;
            stroke: #b45309 !important;
            stroke-width: 2px !important;
        }

        .node-dimmed {
            fill: #d1d5db !important;
            r: 5 !important;
            opacity: 0.5 !important;
        }

        .link-highlighted {
            stroke: #f59e0b !important;
            /* stroke-width will be set by JS dynamically or to a fixed value */
            stroke-opacity: 0.8 !important;
        }

        .link-dimmed {
            stroke: #e5e7eb !important;
            stroke-width: 0.5px !important;
            stroke-opacity: 0.3 !important;
        }

        .task-link {
            cursor: pointer;
            color: #4f46e5;
            text-decoration: underline;
        }

        .task-link:hover {
            color: #1e40af;
        }

        .filter-active {
            background-color: #f3f4f6;
        }

        .highlighted-node-text {
            display: block !important;
            font-weight: bold !important;
            fill: #b45309 !important;
        }

        .depth-level {
            display: inline-block;
            width: 15px;
            height: 15px;
            border-radius: 50%;
            margin-right: 5px;
        }
    </style>
</head>
<body>

    <div class="flex flex-col w-full p-4 md:p-6 lg:p-8 bg-gray-50">
        <h1 class="text-3xl font-bold text-gray-800 mb-6 text-center">RTOS V2X Scheduler Trace Graph Visualizer</h1>
        <div class="metric-card p-3 mb-4">
             <div class="flex flex-wrap items-center gap-x-4 gap-y-2">
                 <div class="flex items-center">
                    <input type="file" id="fileInput" accept=".txt,.log" class="block w-full text-sm text-gray-500
                        file:mr-3 file:py-1.5 file:px-3
                        file:rounded-full file:border-0 file:text-sm file:font-semibold
                        file:bg-indigo-50 file:text-indigo-700 hover:file:bg-indigo-100">
                 </div>
                 <div class="flex items-center space-x-4 text-sm">
                    <div class="flex items-baseline space-x-1.5">
                        <span class="font-semibold text-gray-600">仅支持V2X调度轨迹数据格式
                        <a href="https://3ms.huawei.com/next/groups/index.html#/wiki/detail?groupId=3828267&wikiId=6571498" class="text-indigo-600 hover:underline">[思路来源] </a>
                        <a href="https://wiki.huawei.com/domains/12565/wiki/179215/WIKI202501105697774" class="text-indigo-600 hover:underline">[调度数据采集]</a>
                        </span>
                    </div>
                 </div>
                 <div class="h-6 border-l border-gray-300 mx-2"></div>

                 <div class="flex items-center space-x-4 text-sm">
                    <div class="flex items-baseline space-x-1.5">
                        <span class="font-semibold text-gray-600">Nodes:</span>
                        <span id="total-nodes-val" class="font-bold text-indigo-600">-</span>
                        <span class="text-gray-500">(<span id="filtered-nodes-val" class="font-bold text-green-600">-</span>)</span>
                    </div>
                    <div class="flex items-baseline space-x-1.5">
                        <span class="font-semibold text-gray-600">Edges:</span>
                        <span id="total-edges-val" class="font-bold text-indigo-600">-</span>
                        <span class="text-gray-500">(<span id="filtered-edges-val" class="font-bold text-green-600">-</span>)</span>
                    </div>
                     <div class="flex items-baseline space-x-1.5">
                        <span class="font-semibold text-gray-600">Switches:</span>
                        <span id="total-switches-val" class="font-bold text-indigo-600">-</span>
                        <span class="text-gray-500">(<span id="filtered-switches-val" class="font-bold text-green-600">-</span>)</span>
                    </div>
                 </div>

                <div class="h-6 border-l border-gray-300 mx-2"></div>

                 <div id="graph-controls" class="flex flex-wrap items-center space-x-2">
                    <label for="weightThreshold" class="text-sm font-medium text-gray-700 whitespace-nowrap">最小调度次数:</label>
                    <input type="number" id="weightThreshold" value="50" min="1" class="w-20 p-1.5 rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm">
                    
                    <select id="graphDirection" class="p-1.5 rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm ml-2">
                        <option value="undirected">无向图</option>
                        <option value="directed">有向图</option>
                    </select>
                    <span class="text-gray-400 mx-1">|</span>
                    
                    <input type="text" id="nodeSearch" placeholder="搜索任务名" class="w-40 p-1.5 rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm ml-2">
                </div>
             </div>
        </div>

        <div class="flex flex-col lg:flex-row gap-4">
            <div class="metric-card flex-grow lg:w-2/3">
                <div id="graph-container" class="relative">
                    <div id="placeholder" class="text-center text-gray-500 flex items-center justify-center h-full">
                        Please upload your trace data file to begin analysis.
                    </div>
                    <svg id="graph-svg"></svg>
                    <div id="tooltip"></div>
                    <button id="fullscreen-toggle" class="absolute top-2 right-2 z-10 p-1.5 bg-gray-700 bg-opacity-50 text-white rounded hover:bg-opacity-75 text-xs">
                        [ ]
                    </button>
                </div>
            </div>


            <div class="metric-card lg:w-1/4 table-container p-3">
                <div class="flex flex-row items-center justify-between space-x-2 mb-2 pt-1 border-t mt-2"> 

                    <div class="flex items-center">
                        <label for="bfsDepthSelect" class="text-xs font-medium text-gray-600 mr-1 whitespace-nowrap">BFS:</label>
                        <select id="bfsDepthSelect" class="p-1 text-xs rounded border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500" style="min-width: 45px; max-width:55px;">
                            <option value="1">1</option>
                            <option value="2">2</option>
                            <option value="3">3</option>
                            <option value="4">4</option>
                            <option value="5" selected>5</option>
                            <option value="6">6</option>
                            <option value="7">7</option>
                            <option value="8">8</option>
                            <option value="9">9</option>
                            <option value="10">10</option>
                        </select>
                    </div>

                    <div class="flex items-center space-x-1">
                        <span class="text-xs font-medium text-gray-600 hidden sm:inline">Legend:</span>

                        <div class="flex items-center" title="Source Node">
                            <div class="depth-level bg-orange-400 w-2.5 h-2.5"></div> <span class="text-xs text-gray-500 ml-0.5 hidden md:inline">S</span>
                        </div>
                        <div class="flex items-center" title="Level 1">
                            <div class="depth-level bg-yellow-400 w-2.5 h-2.5"></div> <span class="text-xs text-gray-500 ml-0.5 hidden md:inline">L1</span>
                        </div>
                        <div class="flex items-center" title="Level 2+">
                            <div class="depth-level bg-green-400 w-2.5 h-2.5"></div> <span class="text-xs text-gray-500 ml-0.5 hidden md:inline">L2+</span>
                        </div>
                    </div>

                    <button id="resetFilterBtn" class="px-2 py-1 bg-gray-200 text-gray-700 text-xs font-medium rounded shadow-sm hover:bg-gray-300 whitespace-nowrap">
                       Reset
                    </button>
                </div>
                <div class="overflow-x-auto">
                    <table id="links-table" class="w-full text-xs text-left text-gray-500 compact-table">
                        <thead class="text-xs text-gray-700 uppercase bg-gray-50">
                            <tr>
                                <th scope="col" class="px-3 py-2">Task A</th>
                                <th scope="col" class="px-3 py-2">Task B</th>
                                <th scope="col" class="px-3 py-2 text-right">Switches</th>
                            </tr>
                        </thead>
                        <tbody id="links-table-body">
                            <tr>
                                <td colspan="3" class="px-3 py-2 text-center">Upload a file and adjust threshold to see data.</td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const fileInput = document.getElementById('fileInput');
            // const analyzeBtn = document.getElementById('analyzeBtn'); // Removed
            const resetFilterBtn = document.getElementById('resetFilterBtn');
            const weightThresholdInput = document.getElementById('weightThreshold');
            const graphDirectionSelect = document.getElementById('graphDirection');
            const nodeSearchInput = document.getElementById('nodeSearch');
            const bfsDepthSelect = document.getElementById('bfsDepthSelect'); // Changed from bfsDepthInput
            const tooltip = d3.select("#tooltip");
            const placeholder = document.getElementById('placeholder');
            const graphControls = document.getElementById('graph-controls');
            const graphContainer = document.getElementById('graph-container');
            const fullscreenToggleBtn = document.getElementById('fullscreen-toggle'); // New

            // Updated selectors for new count display format
            const totalNodesValEl = document.getElementById('total-nodes-val');
            const filteredNodesValEl = document.getElementById('filtered-nodes-val');
            const totalEdgesValEl = document.getElementById('total-edges-val');
            const filteredEdgesValEl = document.getElementById('filtered-edges-val');
            const totalSwitchesValEl = document.getElementById('total-switches-val');
            const filteredSwitchesValEl = document.getElementById('filtered-switches-val');

            const linksTableBody = document.getElementById('links-table-body');

            let fullGraphData = { nodes: [], links: [] };
            let undirectedGraphData = { nodes: [], links: [] };
            // let currentGraphData = { nodes: [], links: [] }; // This wasn't consistently used; removing to avoid confusion
            let simulation;
            let currentHighlightedNode = null;
            let connectedNodes = new Map();
            let connectedLinks = new Set();
            let g; // Declare g here for wider scope, will be assigned in drawGraph

            // Global cache for currently rendered graph structure by drawGraph
            let currentlyDisplayedNodes = [];
            let currentlyDisplayedLinks = [];
            let lastZoomTransform = null; // To store zoom state
            let highlightedLinkFromTable = null; // For Task 1: Edge Highlighting from Table

            // Helper function to create a thickness scale for links
            function createThicknessScale(linksData, minPx = 1, maxPx = 8) {
                if (!linksData || linksData.length === 0) {
                    return () => (minPx + maxPx) / 2; // Default for empty link sets
                }

                const weights = linksData.map(l => l.weight).filter(w => w > 0); // Filter out non-positive weights for scale domain

                if (weights.length === 0) { // All links had zero or negative weight or were filtered
                    return () => minPx; // Default to minPx if no positive weights
                }

                const minWeight = d3.min(weights);
                const maxWeight = d3.max(weights);

                // This case should ideally be caught by weights.length === 0 if min/max are undefined
                if (minWeight === undefined || maxWeight === undefined) {
                    return () => (minPx + maxPx) / 2;
                }

                if (minWeight === maxWeight) {
                    // If all positive weights are the same, use a thickness in the middle of the range.
                    return () => (minPx + maxPx) / 2;
                }

                // Use d3.scaleSqrt for better visual distinction of weights.
                return d3.scaleSqrt()
                         .domain([minWeight, maxWeight])
                         .range([minPx, maxPx])
                         .clamp(true);
            }


            // 阻止图表容器的滚轮事件冒泡到页面
            graphContainer.addEventListener('wheel', (e) => {
                if (e.ctrlKey) {
                    // 如果按住Ctrl键，允许默认缩放行为
                    return;
                }
                // 否则阻止页面滚动
                e.preventDefault();
            }, { passive: false });

            // analyzeBtn.addEventListener('click', handleAnalysis); // Removed
            fileInput.addEventListener('change', handleAnalysis); // Auto-analyze on file change
            resetFilterBtn.addEventListener('click', resetGraphFilter);
            weightThresholdInput.addEventListener('input', () => {
                console.log(`Weight threshold changed to: ${weightThresholdInput.value}`);
                drawGraph();
            });
            graphDirectionSelect.addEventListener('change', () => {
                console.log(`Graph direction changed to: ${graphDirectionSelect.value}`);
                drawGraph();
            });
            nodeSearchInput.addEventListener('input', debounce(() => {
                console.log(`Search term: ${nodeSearchInput.value}`);
                drawGraph();
            }, 300));
            
            bfsDepthSelect.addEventListener('change', () => { // Changed from bfsDepthInput to bfsDepthSelect
                console.log(`BFS depth changed to: ${bfsDepthSelect.value}`);
                if (currentHighlightedNode) {
                    highlightNodeConnections(currentHighlightedNode);
                }
            });

            function handleAnalysis() {
                const file = fileInput.files[0];
                if (!file) {
                    console.warn('No file selected.');
                    fileInput.focus();
                    return;
                }

                placeholder.textContent = 'Analyzing...';
                placeholder.style.display = 'flex';
                document.getElementById('graph-svg').innerHTML = '';
                linksTableBody.innerHTML = '<tr><td colspan="3" class="px-3 py-2 text-center">Analyzing...</td></tr>';

                if (simulation) simulation.stop();

                const reader = new FileReader();
                reader.onload = (event) => {
                    const text = event.target.result;
                    fullGraphData = parseSchedData(text);
                    console.log('Parsed full graph data:', fullGraphData);
                    if (fullGraphData.nodes.length > 0) {
                        undirectedGraphData = buildUndirectedGraph(fullGraphData);
                        currentGraphData = { ...fullGraphData };
                        console.log('Built undirected graph data:', undirectedGraphData);
                        
                        placeholder.style.display = 'none';
                        updateMetrics(fullGraphData);
                        // currentNodesEl and currentEdgesEl are removed, counts updated in drawGraph
                        drawGraph();
                    } else {
                        placeholder.textContent = 'Could not parse data from file. Please check the format.';
                        linksTableBody.innerHTML = '<tr><td colspan="3" class="px-3 py-2 text-center">Could not parse data from file. Please check the format.</td></tr>';
                    }
                };
                reader.onerror = (error) => {
                    placeholder.textContent = 'Error reading file.';
                    console.error('Error reading file:', error);
                };
                reader.readAsText(file);
            }

            function updateMetrics({nodes, links}) { // This function now sets the "Total" values
                totalNodesValEl.textContent = nodes.length.toLocaleString();
                totalEdgesValEl.textContent = links.length.toLocaleString();
                const totalSwitchesCount = links.reduce((sum, link) => sum + link.weight, 0);
                totalSwitchesValEl.textContent = totalSwitchesCount.toLocaleString();

                // Initialize filtered counts to dash or 0 when new file is loaded, before first drawGraph
                filteredNodesValEl.textContent = '-';
                filteredEdgesValEl.textContent = '-';
                filteredSwitchesValEl.textContent = '-';
            }

            function parseSchedData(text) {
                const lines = text.split('\n');
                const nodeMap = new Map();
                const linkMap = new Map();
                const regex = /prev_comm=([\S]+)\s+prev_pid=\d+\s+prev_tid=([\S]+)[\s\S]*?==>\s+next_comm=([\S]+)\s+next_tid=([\S]+)/;

                for (const line of lines) {
                    const match = line.match(regex);
                    if (match) {
                        const [, prev_comm, prev_tid, next_comm, next_tid] = match;
                        const sourceId = `${prev_comm}/${prev_tid}`;
                        const targetId = `${next_comm}/${next_tid}`;

                        if (sourceId === targetId) continue;

                        if (!nodeMap.has(sourceId)) nodeMap.set(sourceId, { id: sourceId, comm: prev_comm, pid: prev_tid });
                        if (!nodeMap.has(targetId)) nodeMap.set(targetId, { id: targetId, comm: next_comm, pid: next_tid });

                        const linkKey = `${sourceId}->${targetId}`;

                        if (linkMap.has(linkKey)) {
                            linkMap.get(linkKey).weight++;
                        } else {
                            linkMap.set(linkKey, {
                                source: sourceId,
                                target: targetId,
                                weight: 1
                            });
                        }
                    }
                }

                console.log(`Parsed ${nodeMap.size} nodes and ${linkMap.size} links`);
                return {
                    nodes: Array.from(nodeMap.values()),
                    links: Array.from(linkMap.values())
                };
            }

            function buildUndirectedGraph({nodes, links}) {
                const undirectedLinkMap = new Map();
                
                links.forEach(link => {
                    const nodeIds = [link.source, link.target].sort();
                    const undirectedKey = `${nodeIds[0]}->${nodeIds[1]}`;
                    
                    if (undirectedLinkMap.has(undirectedKey)) {
                        undirectedLinkMap.get(undirectedKey).weight += link.weight;
                    } else {
                        undirectedLinkMap.set(undirectedKey, {
                            source: nodeIds[0],
                            target: nodeIds[1],
                            weight: link.weight,
                            originalLinks: [link]
                        });
                    }
                });
                
                console.log(`Built undirected graph with ${nodes.length} nodes and ${undirectedLinkMap.size} links`);
                return {
                    nodes: [...nodes],
                    links: Array.from(undirectedLinkMap.values())
                };
            }

            function drawGraph() {
                console.log('Drawing graph with current settings...');
                if (!fullGraphData.nodes || fullGraphData.nodes.length === 0) {
                    console.log('No graph data available');
                    return;
                }

                const threshold = +weightThresholdInput.value;
                const isDirected = graphDirectionSelect.value === 'directed';
                const searchTerm = nodeSearchInput.value.trim().toLowerCase();
                
                console.log(`Threshold: ${threshold}, Directed: ${isDirected}, Search: ${searchTerm || 'none'}`);
                
                const baseGraphData = isDirected ? fullGraphData : undirectedGraphData;
                
                let { nodes, links } = baseGraphData; // These are initially references from fullGraphData or undirectedGraphData
                
                console.log(`Starting with ${nodes.length} nodes and ${links.length} links`);

                // If drawGraph is called for a general view (not during an active highlight that sets fx/fy),
                // ensure all nodes are released from any prior fixed positions.
                // currentHighlightedNode is null when deselecting or resetting.
                // Note: highlightNodeConnections also clears fx/fy from simulation.nodes()
                // before setting new ones, so this primarily covers the reset path and ensures
                // the base node objects used by drawGraph are clean.
                if (!currentHighlightedNode) {
                    // Create a new array of node objects if nodes are just references, to avoid modifying source data cache directly,
                    // OR ensure that fx/fy are properties solely managed by the simulation instances.
                    // Given D3's behavior, fx/fy are often added to the original objects.
                    // So, it's better to nullify them on the 'nodes' array that will be used.
                    // This 'nodes' array is a fresh copy or filtered list at this point.
                    const allNodesToClear = simulation ? simulation.nodes() : (isDirected ? fullGraphData.nodes : undirectedGraphData.nodes);
                    allNodesToClear.forEach(n => {
                        n.fx = null;
                        n.fy = null;
                    });
                    // If 'nodes' is a filtered subset, ensure those are also cleared.
                    // This might be redundant if 'allNodesToClear' covers them, but safer.
                    nodes.forEach(n => { // 'nodes' is the array that will be passed to the new simulation
                        n.fx = null;
                        n.fy = null;
                    });
                }
                
                if (searchTerm) {
                    const matchedNodes = nodes.filter(node => {
                        const match = node.id.toLowerCase().includes(searchTerm) || 
                            (node.comm && node.comm.toLowerCase().includes(searchTerm)) ||
                            (node.pid && node.pid.toLowerCase().includes(searchTerm));
                        console.log(`Node ${node.id}: ${match ? 'MATCH' : 'NO MATCH'}`);
                        return match;
                    });
                    
                    console.log(`Found ${matchedNodes.length} matched nodes`);
                    
                    if (matchedNodes.length === 0) {
                        console.log('No nodes matched search term');
                        nodes = [];
                        links = [];
                    } else {
                        const matchedNodeIds = new Set(matchedNodes.map(node => node.id));
                        
                        links = links.filter(link => {
                            const match = matchedNodeIds.has(link.source) || matchedNodeIds.has(link.target);
                            console.log(`Link ${link.source} -> ${link.target}: ${match ? 'MATCH' : 'NO MATCH'}`);
                            return match;
                        });
                        
                        const nodesInLinks = new Set([
                            ...links.map(link => link.source),
                            ...links.map(link => link.target)
                        ]);
                        
                        nodes = nodes.filter(node => nodesInLinks.has(node.id));
                        
                        console.log(`Filtered to ${nodes.length} nodes and ${links.length} links after search`);
                    }
                }

                const filteredLinks = links
                    .filter(link => {
                        const match = link.weight >= threshold;
                        console.log(`Link ${link.source} -> ${link.target} (weight ${link.weight}): ${match ? 'PASS' : 'FILTERED'}`);
                        return match;
                    })
                    .sort((a, b) => b.weight - a.weight);

                console.log(`After weight threshold filter: ${filteredLinks.length} links`);
                
                // 调试输出过滤后的边数据
                console.log('Filtered links:', filteredLinks);

                const fullNodeLookup = new Map();
                fullGraphData.nodes.forEach(node => {
                    fullNodeLookup.set(node.id, {
                        id: node.id,
                        comm: node.comm || node.id.split('/')[0],
                        pid: node.pid || node.id.split('/')[1]
                    });
                });

                console.log(`Full node lookup created with ${fullNodeLookup.size} entries`);

                // 更新表格
                linksTableBody.innerHTML = '';

                if (filteredLinks.length === 0) {
                    console.log('No links to display in table');
                    const row = linksTableBody.insertRow();
                    const cell = row.insertCell();
                    cell.colSpan = 3;
                    cell.textContent = 'No links meet the current threshold.';
                    cell.className = 'px-3 py-2 text-center';
                } else {
                    console.log(`Populating table with ${filteredLinks.length} links`);
                    filteredLinks.forEach(link => {
                        // 确保link.source和link.target是字符串ID
                        const sourceId = typeof link.source === 'object' ? link.source.id : link.source;
                        const targetId = typeof link.target === 'object' ? link.target.id : link.target;
                        
                        const sourceNode = fullNodeLookup.get(sourceId);
                        const targetNode = fullNodeLookup.get(targetId);
                        
                        console.log(`Table row: ${sourceId} (${sourceNode ? sourceNode.comm : 'unknown'}) -> ${targetId} (${targetNode ? targetNode.comm : 'unknown'})`);
                        
                        // 额外调试：如果节点未找到，输出更多信息
                        if (!sourceNode) {
                            console.warn(`Source node not found for ID: ${sourceId}`, link);
                        }
                        if (!targetNode) {
                            console.warn(`Target node not found for ID: ${targetId}`, link);
                        }

                        const row = linksTableBody.insertRow();
                        row.className = 'bg-white border-b hover:bg-gray-50 transition-colors cursor-pointer'; // Added cursor-pointer
                        row.setAttribute('data-source-id', sourceId);
                        row.setAttribute('data-target-id', targetId);
                        row.setAttribute('data-weight', link.weight);


                        const cellNodeA = row.insertCell();
                        cellNodeA.innerHTML = sourceNode ? `<span class="task-link" data-node-id="${sourceId}">${sourceNode.comm}/${sourceNode.pid}</span>` : sourceId;
                        cellNodeA.className = 'px-3 py-2 font-medium text-gray-900 whitespace-nowrap';

                        const cellNodeB = row.insertCell();
                        cellNodeB.innerHTML = targetNode ? `<span class="task-link" data-node-id="${targetId}">${targetNode.comm}/${targetNode.pid}</span>` : targetId;
                        cellNodeB.className = 'px-3 py-2';

                        const cellSwitches = row.insertCell();
                        // Wrap weight in a span for specific click targeting
                        cellSwitches.innerHTML = `<span class="switches-value">${link.weight}</span>`;
                        cellSwitches.className = 'px-3 py-2 font-semibold text-indigo-600 text-right';
                    });

                    // 为任务链接添加点击事件
                    document.querySelectorAll('.task-link').forEach(link => {
                        link.addEventListener('click', (e) => {
                            const nodeId = e.currentTarget.getAttribute('data-node-id');
                            highlightNodeConnections(nodeId);
                        });
                    });
                }

                // 图形渲染代码
                const container = document.getElementById('graph-container');
                const svg = d3.select("#graph-svg");

                // Store last transform if available
                // Check if svg.node() exists and is zoomable before getting transform
                if (svg.node() && typeof d3.zoomTransform === 'function' && svg.node().__zoom !== undefined && svg.node().__zoom !== d3.zoomIdentity) {
                     if (g) { // Ensure global g was previously defined (e.g. from a previous draw)
                        lastZoomTransform = d3.zoomTransform(svg.node());
                     }
                }


                svg.selectAll("*").remove(); // This removes 'g' as well if it was part of svg's children

                // Update displayed node and edge counts based on the data *before* simulation
                // These are the nodes and links that will be attempted to be rendered.
                filteredNodesValEl.textContent = nodes.length.toLocaleString();
                filteredEdgesValEl.textContent = filteredLinks.length.toLocaleString();
                const filteredSwitchesCount = filteredLinks.reduce((sum, link) => sum + link.weight, 0);
                filteredSwitchesValEl.textContent = filteredSwitchesCount.toLocaleString();

                // Cache the exact nodes and links being rendered for BFS in highlightNodeConnections
                currentlyDisplayedNodes = [...nodes]; // Store a copy
                currentlyDisplayedLinks = [...filteredLinks]; // Store a copy


                const width = container.clientWidth;
                const height = container.clientHeight;

                g = svg.append("g"); // Assign to the higher-scoped 'g'

                if (isDirected) {
                    svg.append("defs").append("marker")
                        .attr("id", "arrowhead")
                        // viewBox="0 0 <marker-length> <marker-height>"
                        .attr("viewBox", "0 0 5 3.5") // Adjusted viewBox for a 5x3.5 marker
                        // refX is distance from node center to the marker's reference point.
                        // Node radius is 8. Path tip is at x=5. refX=4 means (4,1.75) of marker is at node center.
                        // Tip (5,1.75) is 1px past node center.
                        .attr("refX", 4)
                        .attr("refY", 1.75) // Mid-point of marker height 3.5
                        .attr("markerWidth", 5) // Visual width of the marker
                        .attr("markerHeight", 3.5)  // Visual height of the marker
                        .attr("orient", "auto")
                        .append("path")
                        // Path for a 5x3.5 arrowhead: M0,0 L5,1.75 L0,3.5
                        .attr("d", "M 0 0 L 5 1.75 L 0 3.5 z")
                        .attr("class", "arrowhead");
                }

                // 确保links数据格式正确
                const formattedLinks = filteredLinks.map(link => ({
                    ...link,
                    source: typeof link.source === 'object' ? link.source.id : link.source,
                    target: typeof link.target === 'object' ? link.target.id : link.target
                }));

                simulation = d3.forceSimulation(nodes)
                    .force("link", d3.forceLink(formattedLinks).id(d => d.id)

                        .strength(d => 0.08 * Math.sqrt(d.weight / (d3.max(formattedLinks, l => l.weight) || 1))) // Re-introduced dynamic link strength
                        )
                    .force("charge", d3.forceManyBody().strength(-500)) // Moderately increased repulsion
                    .force("center", d3.forceCenter(width / 2, height / 2))
                    .force("collide", d3.forceCollide().radius(22).strength(0.7)); // Moderately increased collision radius with custom strength

                // Draw nodes first so links (and arrowheads) appear on top.
                const nodeGroup = g.append("g")
                    .selectAll("g")
                    .data(nodes)
                    .join("g")
                    .attr("class", "node");

                nodeGroup.append("circle")
                    .attr("r", 8)
                    .attr("fill", "#4f46e5")
                    .attr("stroke", "#fff")
                    .attr("stroke-width", 1.5);

                nodeGroup.append("text")
                    .text(d => `${d.comm}/${d.pid}`)
                    .attr("x", 12)
                    .attr("y", 4)
                    .attr("font-size", "12px")
                    .attr("font-family", "monospace")
                    .attr("fill", "#333")
                    .style("display", "none")
                    .style("pointer-events", "none");

                nodeGroup.on("mouseover", function(event, d) {
                        d3.select(this).select('text').style('display', 'block');
                        tooltip.style("opacity", 1).html(`任务: ${d.id}`);
                    })
                    .on("mousemove", (event) => {
                        tooltip.style("left", (event.pageX + 15) + "px")
                               .style("top", (event.pageY - 28) + "px");
                    })
                    .on("mouseout", function() {
                        d3.select(this).select('text').style('display', 'none');
                        tooltip.style("opacity", 0);
                    })
                    .on("click", function(event, d) {
                        highlightNodeConnections(d.id);
                    });

                const drag = d3.drag()
                    .on("start", (event, d) => {
                        if (!event.active) simulation.alphaTarget(0.3).restart();
                        d.fx = d.x;
                        d.fy = d.y;
                    })
                    .on("drag", (event, d) => {
                        d.fx = event.x;
                        d.fy = event.y;
                    })
                    .on("end", (event, d) => {
                        if (!event.active) simulation.alphaTarget(0);
                        d.fx = null;
                        d.fy = null;
                    });

                nodeGroup.call(drag);

                // Now, draw links so they appear on top of nodes.
                const linkGroup = g.append("g")
                    .selectAll("g")
                    .data(formattedLinks)
                    .join("g")
                    .attr("class", "link-group");

                const linkLine = linkGroup.append("line")
                    .attr("stroke", "#999")
                    .attr("stroke-opacity", 0.6);
                    // stroke-width will be set dynamically below

                // Dynamic edge thickness logic using the new helper function
                // Using a range like [0.8, 10] for general view for potentially finer thin lines and thicker max lines
                const thicknessScale = createThicknessScale(formattedLinks, 0.8, 10);
                linkLine.attr("stroke-width", d => thicknessScale(d.weight));

                if (isDirected) {
                    linkLine.attr("marker-end", "url(#arrowhead)");
                }

                linkGroup.append("text")
                    .text(d => d.weight)
                    .attr("font-size", "10px")
                    .attr("font-family", "sans-serif")
                    .attr("fill", "#333")
                    .attr("stroke", "white")
                    .attr("stroke-width", 0.4)
                    .attr("paint-order", "stroke")
                    .style("display", "none")
                    .style("pointer-events", "none");

                linkGroup
                    .on("mouseover", function(event, d) {
                        d3.select(this).select('text').style('display', 'block');
                        tooltip.style("opacity", 1).html(`切换次数: ${d.weight}`);
                    })
                    .on("mousemove", (event) => {
                        tooltip.style("left", (event.pageX + 15) + "px")
                               .style("top", (event.pageY - 28) + "px");
                    })
                    .on("mouseout", function() {
                        d3.select(this).select('text').style('display', 'none');
                        tooltip.style("opacity", 0);
                    });


                const zoom = d3.zoom()
                    .scaleExtent([0.1, 10])
                    .on("zoom", (event) => {
                        g.attr("transform", event.transform);
                    });

                svg.call(zoom);

                // Apply the stored transform
                if (lastZoomTransform) {
                    // svg.call(zoom.transform, lastZoomTransform); //This is the correct way
                    // For older d3, or if 'g' is the transformed element directly by zoom event:
                     g.attr('transform', lastZoomTransform.toString());
                     // To make the zoom behavior aware of this new transform:
                     d3.select(svg.node()).call(zoom.transform, lastZoomTransform);

                }


                simulation.on("tick", () => {
                    linkGroup.select("line")
                        .attr("x1", d => d.source.x)
                        .attr("y1", d => d.source.y)
                        .attr("x2", d => d.target.x)
                        .attr("y2", d => d.target.y);

                    linkGroup.select("text")
                        .attr("x", d => (d.source.x + d.target.x) / 2)
                        .attr("y", d => (d.source.y + d.target.y) / 2);

                    nodeGroup.attr("transform", d => `translate(${d.x},${d.y})`);
                });
                
                console.log('Graph drawing completed');
                
                // 如果有当前高亮节点，重新应用高亮
                if (currentHighlightedNode) {
                    highlightNodeConnections(currentHighlightedNode);
                }
            }

            function highlightNodeConnections(nodeId) {
                // If a single link from table was highlighted, clear that state first.
                if (highlightedLinkFromTable) {
                    highlightedLinkFromTable = null;
                    document.querySelectorAll('#links-table-body tr').forEach(row => row.classList.remove('bg-indigo-100'));
                    // The call to drawGraph() or subsequent style updates in this function will override single link styles.
                }

                const currentBfsDepth = bfsDepthSelect.value; // Use new select element
                console.log(`Highlighting connections for node: ${nodeId} with BFS depth: ${currentBfsDepth}`);
                
                // 重置之前的高亮状态 (visual styles related to BFS highlighting)
                // Note: fx/fy clearing and node/link styling for BFS happens later in this function.
                // The lines below primarily reset classes, which is fine.
                d3.selectAll('.node circle').classed('node-highlighted', false).classed('node-dimmed', false);
                d3.selectAll('.link-group line').classed('link-highlighted', false).classed('link-dimmed', false);
                d3.selectAll('.node text').classed('highlighted-node-text', false);
                
                // 如果点击同一个节点，取消高亮
                if (currentHighlightedNode === nodeId) {
                    currentHighlightedNode = null;
                    connectedNodes.clear();
                    connectedLinks.clear();
                    document.querySelectorAll('.task-link').forEach(link => {
                        link.classList.remove('font-bold', 'text-indigo-700');
                    });
                    // When un-highlighting, revert to counts from the main drawGraph function
                    // This typically means re-calling drawGraph or ensuring its last calculated counts are displayed.
                    // For simplicity here, we'll call drawGraph to reset view and counts.
                    drawGraph();
                    return;
                }
                
                currentHighlightedNode = nodeId;
                connectedNodes.clear();
                connectedLinks.clear();
                
                const isDirected = graphDirectionSelect.value === 'directed'; // Keep for link directionality if needed in BFS
                const maxDepth = +bfsDepthSelect.value;

                // Use the cached currently displayed nodes and links for BFS
                const nodesForBfs = currentlyDisplayedNodes;
                const linksForBfs = currentlyDisplayedLinks;

                // Check if the selected node for highlighting even exists in the currently displayed nodes.
                const startNodeInDisplayed = nodesForBfs.find(n => n.id === nodeId);
                if (!startNodeInDisplayed) {
                    console.warn(`Node ${nodeId} selected for highlighting but not found in currently displayed nodes. Aborting highlight.`);
                    // Reset to a clean state if the start node isn't even visible.
                    // This might happen if filters changed between click and processing, though unlikely with current setup.
                    d3.selectAll('.node circle').classed('node-highlighted', false).classed('node-dimmed', false).attr('fill', '#4f46e5');
                    d3.selectAll('.link-group line').classed('link-highlighted', false).classed('link-dimmed', false);
                    d3.selectAll('.node text').classed('highlighted-node-text', false);
                    // Ensure counts reflect the current general view if highlight aborts
                    // Corrected variable names:
                    filteredNodesValEl.textContent = currentlyDisplayedNodes.length.toLocaleString();
                    filteredEdgesValEl.textContent = currentlyDisplayedLinks.length.toLocaleString();
                    currentHighlightedNode = null; // Clear highlight state
                    return;
                }
                
                const queue = [{id: nodeId, depth: 0}];
                connectedNodes.set(nodeId, 0); // Map of {id: depth}
                
                let head = 0; // Using simple array queue, head index to simulate shift() for performance
                while(head < queue.length) {
                    const {id: currentId, depth: currentDepth} = queue[head++];
                    
                    if (currentDepth >= maxDepth) continue;
                    
                    linksForBfs.forEach(link => {
                        // Ensure link source/target are IDs, not objects, for comparison
                        const linkSourceId = (typeof link.source === 'object') ? link.source.id : link.source;
                        const linkTargetId = (typeof link.target === 'object') ? link.target.id : link.target;

                        let neighborId = null;

                        if (linkSourceId === currentId) {
                            neighborId = linkTargetId;
                        } else if (!isDirected && linkTargetId === currentId) {
                            neighborId = linkSourceId;
                        }
                        // For directed graphs, if link.target === currentId, it's an incoming link.
                        // The current BFS explores "outgoing" from nodeId. If "incoming" also desired, logic here would change.

                        if (neighborId) {
                            // Check if neighbor is in the set of currently displayed nodes
                            const neighborInDisplayed = nodesForBfs.find(n => n.id === neighborId);
                            if (!neighborInDisplayed) return; // Skip if neighbor isn't currently visible

                            const linkKey = `${linkSourceId}->${linkTargetId}`; // Standardized key with '->'

                            if (!connectedNodes.has(neighborId) || connectedNodes.get(neighborId) > currentDepth + 1) {
                                connectedNodes.set(neighborId, currentDepth + 1);
                                queue.push({id: neighborId, depth: currentDepth + 1});
                                connectedLinks.add(linkKey);
                            } else if (connectedNodes.has(neighborId) && (connectedNodes.get(neighborId) === currentDepth + 1 || currentDepth < connectedNodes.get(neighborId))) {
                                // If already visited but this path is shorter or same (for multi-path to same node within depth)
                                // ensure link is added if it's part of *any* valid path to a connected node
                                connectedLinks.add(linkKey);
                            }
                        }
                    });
                }
                console.log(`BFS from ${nodeId} (depth ${maxDepth}) found ${connectedNodes.size} nodes and ${connectedLinks.size} links within the currently displayed graph.`);

                // Clear fx, fy for all nodes before applying new hierarchical layout
                // This ensures nodes not in the current selection are released
                simulation.nodes().forEach(node => {
                    node.fx = null;
                    node.fy = null;
                });

                // Group nodes by BFS depth
                const nodesByDepth = [];
                connectedNodes.forEach((depth, id) => {
                    while (nodesByDepth.length <= depth) {
                        nodesByDepth.push([]);
                    }
                    // Find the actual node object to store, not just ID
                    const nodeObject = simulation.nodes().find(n => n.id === id);
                    if (nodeObject) {
                         nodesByDepth[depth].push(nodeObject);
                    }
                });

                const containerWidth = graphContainer.clientWidth;
                // const containerHeight = graphContainer.clientHeight; // Not strictly needed for Y calc this way
                const initialOffsetY = 80; // Increased offset from top
                const levelHeight = 150;  // Increased vertical spacing between levels (was 120)

                nodesByDepth.forEach((nodesInLevel, depth) => {
                    const targetY = initialOffsetY + depth * levelHeight;
                    const numNodesInLevel = nodesInLevel.length;
                    const nodeVisualRadius = 8; // Actual node radius
                    const minNodeSpacing = 24; // Desired minimum space between node edges (was 16)

                    const requiredWidthForLevel = (numNodesInLevel * nodeVisualRadius * 2) + Math.max(0, numNodesInLevel - 1) * minNodeSpacing;
                    let startXForLevel = (containerWidth - requiredWidthForLevel) / 2;

                    // If requiredWidthForLevel is greater than containerWidth, start from a fixed padding
                    // to prevent negative startX, allowing content to flow off-screen.
                    if (requiredWidthForLevel > containerWidth) {
                        startXForLevel = 20; // Or some other small padding
                    }

                    nodesInLevel.forEach((node, i) => {
                        node.fx = startXForLevel + (i * (nodeVisualRadius * 2 + minNodeSpacing)) + nodeVisualRadius;
                        node.fy = targetY; // targetY is already calculated for the current depth
                    });
                });
                
                // Reheat simulation slightly to let links adjust to new fixed positions
                if (simulation) {
                    simulation.alpha(0.1).restart();
                }


                // Update node visual styles (colors, sizes)
                d3.selectAll('.node circle').each(function(d_node) { // d_node is the datum from D3
                    const isConnected = connectedNodes.has(d_node.id);
                    if (isConnected) {
                        const depth = connectedNodes.get(d_node.id);
                        let fillColor;
                        if (depth === 0) fillColor = '#f59e0b'; // Source
                        else if (depth === 1) fillColor = '#eab308'; // Level 1
                        else fillColor = '#22c55e'; // Level 2+
                        
                        d3.select(this)
                            .attr('fill', fillColor)
                            .classed('node-highlighted', true)
                            .classed('node-dimmed', false);
                        d3.select(this.parentNode).select('text').classed('highlighted-node-text', true);
                    } else {
                        // For nodes not in connectedNodes, ensure they are dimmed and fx/fy are cleared (done above)
                        d3.select(this).classed('node-highlighted', false).classed('node-dimmed', true);
                         d3.select(this.parentNode).select('text').classed('highlighted-node-text', false);
                    }
                });
                
                // Update link visual styles
                const isFullscreenActive = document.fullscreenElement === graphContainer ||
                                         document.mozFullScreenElement === graphContainer ||
                                         document.webkitFullscreenElement === graphContainer ||
                                         document.msFullscreenElement === graphContainer;

                let highlightedLinkObjects = [];
                if (connectedLinks.size > 0) { // connectedLinks stores keys like "sourceId-targetId" from BFS
                    linksForBfs.forEach(linkFromDisplayed => { // linksForBfs is currentlyDisplayedLinks
                        const sourceIdStr = (typeof linkFromDisplayed.source === 'object') ? linkFromDisplayed.source.id : linkFromDisplayed.source;
                        const targetIdStr = (typeof linkFromDisplayed.target === 'object') ? linkFromDisplayed.target.id : linkFromDisplayed.target;

                        // Check if this link (or its reverse for undirected) was found in BFS path
                        if (connectedLinks.has(`${sourceIdStr}-${targetIdStr}`) ||
                            (!isDirected && connectedLinks.has(`${targetIdStr}-${sourceIdStr}`))) {
                             highlightedLinkObjects.push(linkFromDisplayed);
                        }
                    });
                }

                // Create a thickness scale for the highlighted links.
                // This will now apply regardless of fullscreen mode.
                // Using a range like [1.5, 10] to make highlighted links generally a bit thicker.
                const highlightedThicknessScale = createThicknessScale(highlightedLinkObjects, 1.5, 10);

                d3.selectAll('.link-group line').each(function(d_link_datum) {
                    const sourceId = (typeof d_link_datum.source === 'object') ? d_link_datum.source.id : d_link_datum.source;
                    const targetId = (typeof d_link_datum.target === 'object') ? d_link_datum.target.id : d_link_datum.target;

                    // Check if this d_link_datum (from the general D3 selection) corresponds to a link in highlightedLinkObjects
                    const isConnectedLink = highlightedLinkObjects.some(hlo =>
                        ((typeof hlo.source === 'object' ? hlo.source.id : hlo.source) === sourceId &&
                         (typeof hlo.target === 'object' ? hlo.target.id : hlo.target) === targetId) ||
                        // For undirected graphs, the link might be stored reversed in highlightedLinkObjects compared to d_link_datum
                        (!isDirected && (typeof hlo.source === 'object' ? hlo.source.id : hlo.source) === targetId &&
                         (typeof hlo.target === 'object' ? hlo.target.id : hlo.target) === sourceId)
                    );

                    if (isConnectedLink) {
                        d3.select(this)
                            .classed('link-highlighted', true)
                            .classed('link-dimmed', false)
                            .attr('stroke-width', highlightedThicknessScale(d_link_datum.weight));
                    } else {
                        d3.select(this).classed('link-highlighted', false).classed('link-dimmed', true);
                        // For dimmed links, their stroke-width is determined by .link-dimmed CSS (0.5px !important)
                        // or could be set explicitly if CSS wasn't !important:
                        // .attr('stroke-width', 0.5);
                        // or by the general scale in drawGraph if it's not !important.
                        // To be safe, ensure it's thin if .link-dimmed CSS doesn't specify width.
                        // The .link-dimmed class has stroke-width: 0.5px !important, so this is fine.
                    }
                });
                
                // 更新表格中的高亮
                document.querySelectorAll('.task-link').forEach(link => {
                    if (link.getAttribute('data-node-id') === nodeId) {
                        link.classList.add('font-bold', 'text-indigo-700');
                    } else {
                        link.classList.remove('font-bold', 'text-indigo-700');
                    }
                });
                
                // 更新当前显示的节点数和边数 (Filtered values)
                filteredNodesValEl.textContent = connectedNodes.size.toLocaleString();
                filteredEdgesValEl.textContent = connectedLinks.size.toLocaleString();
                // For switches, sum the weights of the connectedLinks
                let highlightedSwitchesCount = 0;
                const allLinksForWeightLookup = currentlyDisplayedLinks; // Or merge fullGraphData.links if original weights needed and not on currentlyDisplayedLinks
                connectedLinks.forEach(linkKey => {
                    // linkKey is sourceId-targetId. Need to find the link object to get its weight.
                    // This is a bit inefficient if linksForBfs is large.
                    // Consider if connectedLinks should store link objects or if weights need to be summed differently.
                    // For now, assuming linkKey is sufficient if currentlyDisplayedLinks contains these keys.
                    const parts = linkKey.split('->'); // Standardized key with '->'
                    let sourceIdKey = parts[0];
                    let targetIdKey = parts[1]; // Assuming targetId does not contain '->'

                    // For undirected graphs, keys in allLinksForWeightLookup are sorted alphabetically.
                    // The linkKey from BFS (based on traversal) might not be, so sort it for lookup.
                    if (!isDirected) {
                        const sortedKeys = [sourceIdKey, targetIdKey].sort();
                        sourceIdKey = sortedKeys[0];
                        targetIdKey = sortedKeys[1];
                    }

                    const actualLink = allLinksForWeightLookup.find(l => {
                        // In allLinksForWeightLookup (derived from formattedLinks), source/target are already IDs.
                        const lSource = l.source;
                        const lTarget = l.target;
                        return (lSource === sourceIdKey && lTarget === targetIdKey);
                    }
                    );
                    if (actualLink) {
                        highlightedSwitchesCount += actualLink.weight;
                    }
                });
                filteredSwitchesValEl.textContent = highlightedSwitchesCount.toLocaleString();
            }

            function resetGraphFilter() {
                console.log('Resetting graph filter');

                // Clear single link highlight state from table
                highlightedLinkFromTable = null;
                document.querySelectorAll('#links-table-body tr').forEach(row => row.classList.remove('bg-indigo-100'));
                // updateGraphForTableLinkHighlight(); // Call to reset styles if it was active
                // No, drawGraph will reset styles.

                currentHighlightedNode = null; // Clear any BFS node highlight state
                connectedNodes.clear();
                connectedLinks.clear();
                // Clear any node selection styling from table cells (task-links)
                 document.querySelectorAll('#links-table-body .task-link').forEach(link => {
                    link.classList.remove('font-bold', 'text-indigo-700');
                });


                // Reset input fields to defaults if desired, or simply redraw
                // weightThresholdInput.value = "50"; // Or initial default
                // nodeSearchInput.value = "";
                // graphDirectionSelect.value = "undirected"; // Or initial default
                // bfsDepthSelect.value = "5"; // Or initial default

                // Redraw the graph with original filters/no filters.
                // This will also update displayedNodesCountEl and displayedEdgesCountEl.
                drawGraph();
                
                // The d3 selections for highlighting are reset within drawGraph or highlightNodeConnections(null)
                // If drawGraph() doesn't fully reset all visual states (e.g. table highlights), do it here:
                document.querySelectorAll('.task-link').forEach(link => {
                    link.classList.remove('font-bold', 'text-indigo-700');
                });
            }

            function debounce(func, delay) {
                let timeout;
                return function() {
                    const context = this;
                    const args = arguments;
                    clearTimeout(timeout);
                    timeout = setTimeout(() => func.apply(context, args), delay);
                };
            }

            // Fullscreen API handling
            function isFullscreenApiAvailable() {
                return document.fullscreenEnabled ||
                       document.mozFullScreenEnabled ||
                       document.webkitFullscreenEnabled ||
                       document.msFullscreenEnabled || false;
            }

            function toggleFullscreen() {
                const isCurrentlyFullscreen = document.fullscreenElement ||
                                            document.mozFullScreenElement ||
                                            document.webkitFullscreenElement ||
                                            document.msFullscreenElement;

                if (!isCurrentlyFullscreen) { // Not in fullscreen, try to enter
                    if (!isFullscreenApiAvailable()) {
                        console.warn("Fullscreen API is not available or not allowed in this context (e.g., missing iframe 'allowfullscreen' attribute).");
                        alert("Fullscreen mode is not available or not allowed in this environment."); // Optional: alert user
                        return;
                    }

                    if (graphContainer.requestFullscreen) {
                        graphContainer.requestFullscreen();
                    } else if (graphContainer.mozRequestFullScreen) { /* Firefox */
                        graphContainer.mozRequestFullScreen();
                    } else if (graphContainer.webkitRequestFullscreen) { /* Chrome, Safari & Opera */
                        graphContainer.webkitRequestFullscreen();
                    } else if (graphContainer.msRequestFullscreen) { /* IE/Edge */
                        graphContainer.msRequestFullscreen();
                    }
                } else { // In fullscreen, try to exit
                    if (document.exitFullscreen) {
                        document.exitFullscreen();
                    } else if (document.mozCancelFullScreen) { /* Firefox */
                        document.mozCancelFullScreen();
                    } else if (document.webkitExitFullscreen) { /* Chrome, Safari & Opera */
                        document.webkitExitFullscreen();
                    } else if (document.msExitFullscreen) { /* IE/Edge */
                        document.msExitFullscreen();
                    }
                }
            }

            fullscreenToggleBtn.addEventListener('click', toggleFullscreen);

            function updateFullscreenButton() {
                const isGraphFullscreen = document.fullscreenElement === graphContainer ||
                                       document.mozFullScreenElement === graphContainer ||
                                       document.webkitFullscreenElement === graphContainer ||
                                       document.msFullscreenElement === graphContainer;
                if (isGraphFullscreen) {
                    fullscreenToggleBtn.textContent = 'X'; // Exit fullscreen icon
                } else {
                    fullscreenToggleBtn.textContent = '[ ]'; // Enter fullscreen icon
                }
                return isGraphFullscreen;
            }

            function handleFullscreenChange() {
                const isGraphNowFullscreen = updateFullscreenButton();
                console.log("Fullscreen state changed. Graph is fullscreen:", isGraphNowFullscreen);

                // Trigger a redraw to adapt to new dimensions
                if (fullGraphData.nodes && fullGraphData.nodes.length > 0) {
                    setTimeout(() => {
                        // If drawGraph reinitializes simulation, that's fine.
                        // If it doesn't, we might need to update forces here.
                        // drawGraph() already recalculates width/height and re-centers.
                        drawGraph();

                        // Ensure simulation adapts if it's already running
                        if (simulation && simulation.nodes().length > 0) {
                             const newWidth = graphContainer.clientWidth;
                             const newHeight = graphContainer.clientHeight;
                             simulation.force("center", d3.forceCenter(newWidth / 2, newHeight / 2));
                             // simulation.alpha(0.3).restart(); // Reheat simulation may or may not be desired on every resize
                        }
                        console.log("Graph redraw triggered due to fullscreen change.");
                    }, 150); // Delay to allow DOM to settle
                }
            }

            document.addEventListener('fullscreenchange', handleFullscreenChange);
            document.addEventListener('mozfullscreenchange', handleFullscreenChange);
            document.addEventListener('webkitfullscreenchange', handleFullscreenChange);
            document.addEventListener('msfullscreenchange', handleFullscreenChange);

            // Initial button state update
            updateFullscreenButton();

            // --- Task 1: Edge Highlighting from Table Click ---
            linksTableBody.addEventListener('click', function(event) {

                const clickedTaskLink = event.target.closest('.task-link');
                const clickedSwitchesValue = event.target.closest('.switches-value');
                const targetRow = event.target.closest('tr');

                if (!targetRow) return; // Clicked outside of any row context

                // Clear previous table row highlights first
                document.querySelectorAll('#links-table-body tr').forEach(row => row.classList.remove('bg-indigo-100'));

                if (clickedTaskLink) {
                    const nodeId = clickedTaskLink.getAttribute('data-node-id');

                    console.log(`Task link clicked for BFS: ${nodeId}`);

                    if (highlightedLinkFromTable) {
                        updateGraphForTableLinkHighlight(true); // Clear single-link effects and sets highlightedLinkFromTable = null
                    }

                    // Clear task-link specific styling from other cells before applying to current
                    document.querySelectorAll('#links-table-body .task-link').forEach(link => {
                        link.classList.remove('font-bold', 'text-indigo-700'); // Assuming this was for task-link specific emphasis
                    });
                    // Apply any specific styling to the clicked task-link itself if needed (e.g. bold)
                    // clickedTaskLink.classList.add('font-bold', 'text-indigo-700'); // Example

                    targetRow.classList.add('bg-indigo-100'); // Highlight clicked row

                    if (currentHighlightedNode === nodeId) { // Clicking same task link to deselect BFS
                        console.log(`Deselecting BFS for node: ${nodeId}`);
                        resetGraphFilter(); // Resets all highlights and redraws default graph
                    } else { // Clicking new or different task link for BFS
                        console.log(`Initiating BFS for node: ${nodeId}`);
                        highlightNodeConnections(nodeId);
                    }


                } else if (clickedSwitchesValue) {
                    const sourceId = targetRow.getAttribute('data-source-id');
                    const targetId = targetRow.getAttribute('data-target-id');
                    const weight = targetRow.getAttribute('data-weight');

                    if (!sourceId || !targetId) {
                        console.warn("Row for switches click missing source/target ID.");
                        return;
                    }
                    console.log(`Switches value clicked for edge: ${sourceId} -> ${targetId}, Weight: ${weight}`);

                    if (currentHighlightedNode) { // If BFS highlight is active
                        resetGraphFilter(); // Clears BFS highlight, currentHighlightedNode, and calls drawGraph
                                            // resetGraphFilter also clears highlightedLinkFromTable.
                    }

                    highlightedLinkFromTable = { sourceId, targetId, weight: parseInt(weight) };
                    updateGraphForTableLinkHighlight(); // Apply single edge highlight styles
                    targetRow.classList.add('bg-indigo-100');

                } else {
                    // Clicked on a row but not on a specific interactive element (task-link or switches-value)
                    // Optionally, could still implement the old general row click for single link highlight here,
                    // or do nothing. For now, let's do nothing to keep it specific.
                    console.log("Clicked on table row padding or non-specific area.");
                }

            });

            function updateGraphForTableLinkHighlight(clearOnly = false) {
                if (!simulation || !simulation.nodes() || !g) {
                    console.warn("Simulation or graph group not ready for single link highlight/clear.");
                    return;
                }

                if (clearOnly || !highlightedLinkFromTable) {
                    // Reset styles for all links and nodes to their default appearance
                    g.selectAll('.link-group').each(function(d_link) {
                        const line = d3.select(this).select('line');
                        const text = d3.select(this).select('text');
                        // Use currentlyDisplayedLinks for the scale, as it reflects the main graph's links
                        const generalThicknessScale = createThicknessScale(currentlyDisplayedLinks || [], 0.8, 10);

                        line.attr('stroke', '#999')
                            .attr('stroke-opacity', 0.6)
                            .attr('stroke-width', generalThicknessScale(d_link.weight));

                        // Re-apply marker based on current graph direction state
                        if (graphDirectionSelect.value === 'directed') {
                            line.attr("marker-end", "url(#arrowhead)");
                        } else {
                            line.attr("marker-end", null);
                        }
                        text.style('display', 'none').style('font-weight', 'normal'); // Reset font weight
                    });

                    g.selectAll('.node').each(function(d_node) {
                        const circle = d3.select(this).select('circle');
                        const text = d3.select(this).select('text');

                        circle.attr('fill', '#4f46e5') // Default node color
                              .attr('r', 8) // Default radius
                              .classed('node-highlighted', false)
                              .classed('node-dimmed', false);
                        text.style('display', 'none').classed('highlighted-node-text', false);
                    });

                    if (clearOnly) {
                        highlightedLinkFromTable = null;
                        // Table row highlight is managed by the caller or resetGraphFilter
                    }
                    return;
                }

                // If we reach here, highlightedLinkFromTable is set and clearOnly is false.
                // Ensure currentHighlightedNode (BFS highlight) is cleared. This should ideally be done by the caller.
                if (currentHighlightedNode) {
                    console.warn("updateGraphForTableLinkHighlight (applying highlight) called while currentHighlightedNode is active. BFS highlight should be cleared by caller first.");
                    // For safety, clearing BFS fixed positions if any. Styles will be overridden below.

                    simulation.nodes().forEach(n => { n.fx = null; n.fy = null; });
                    currentHighlightedNode = null;
                    connectedNodes.clear();
                    connectedLinks.clear();

                     // A full drawGraph() might be better here to reset all node/link states before applying single link highlight.
                    // For now, we assume the caller (table click listener) has called resetGraphFilter if needed.
                }

                const { sourceId, targetId, weight } = highlightedLinkFromTable;

                g.selectAll('.link-group').each(function(d_link) {
                    const line = d3.select(this).select('line');
                    const text = d3.select(this).select('text');
                    const linkSourceId = typeof d_link.source === 'object' ? d_link.source.id : d_link.source;
                    const linkTargetId = typeof d_link.target === 'object' ? d_link.target.id : d_link.target;

                    if (linkSourceId === sourceId && linkTargetId === targetId) {
                        line.attr('stroke', '#1e40af') // Distinct highlight color (e.g., strong blue)
                            .attr('stroke-opacity', 1)
                            .attr('stroke-width', Math.max(createThicknessScale([d_link], 1.5, 10)(d_link.weight), 4)); // Make it noticeably thick
                        text.style('display', 'block').style('font-weight', 'bold');
                    } else {
                        line.attr('stroke', '#e5e7eb') // Dim color
                            .attr('stroke-opacity', 0.3)
                            .attr('stroke-width', 0.5);
                        text.style('display', 'none');
                    }
                });

                g.selectAll('.node').each(function(d_node) {
                    const circle = d3.select(this).select('circle');
                    const text = d3.select(this).select('text');
                    if (d_node.id === sourceId || d_node.id === targetId) {
                        circle.attr('fill', '#f59e0b') // Highlight color for connected nodes
                              .attr('r', 10);
                        text.style('display', 'block').classed('highlighted-node-text', true);
                    } else {
                        circle.attr('fill', '#d1d5db') // Dim color for other nodes
                              .attr('r', 5);
                        text.style('display', 'none').classed('highlighted-node-text', false);
                    }
                });
            }
            // --- End Task 1 ---
        });
    </script>
</body>
</html>    
