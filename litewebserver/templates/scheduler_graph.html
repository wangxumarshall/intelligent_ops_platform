<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Scheduler Trace Visualizer</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            background-color: #f8f9fa;
        }

        .metric-card {
            background-color: white;
            border-radius: 0.75rem;
            box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
        }

        #graph-container {
            height: 100vh;
            position: relative;
            cursor: move;
            overflow: hidden;
        }

        svg {
            width: 100%;
            height: 100%;
            display: block;
        }

        .node, .link-group {
            cursor: pointer;
        }

        #tooltip {
            position: absolute;
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 6px 10px;
            border-radius: 4px;
            font-size: 0.85rem;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
        }

        .arrowhead {
            fill: #999;
        }

        .table-container {
            max-height: 100vh;
            overflow-y: auto;
        }

        .compact-table th, .compact-table td {
            padding: 0.3rem 0.5rem;
        }

        .node-highlighted {
            fill: #f59e0b !important;
            r: 10 !important;
            stroke: #b45309 !important;
            stroke-width: 2px !important;
        }

        .node-dimmed {
            fill: #d1d5db !important;
            r: 5 !important;
            opacity: 0.5 !important;
        }

        .link-highlighted {
            stroke: #f59e0b !important;
            stroke-width: 2px !important;
            stroke-opacity: 0.8 !important;
        }

        .link-dimmed {
            stroke: #e5e7eb !important;
            stroke-width: 0.5px !important;
            stroke-opacity: 0.3 !important;
        }

        .task-link {
            cursor: pointer;
            color: #4f46e5;
            text-decoration: underline;
        }

        .task-link:hover {
            color: #1e40af;
        }

        .filter-active {
            background-color: #f3f4f6;
        }

        .highlighted-node-text {
            display: block !important;
            font-weight: bold !important;
            fill: #b45309 !important;
        }

        .depth-level {
            display: inline-block;
            width: 15px;
            height: 15px;
            border-radius: 50%;
            margin-right: 5px;
        }
    </style>
</head>
<body>

    <div class="flex flex-col w-full p-4 md:p-6 lg:p-8 bg-gray-50">
        <h1 class="text-3xl font-bold text-gray-800 mb-6 text-center">RTOS V2X Scheduler Trace Graph Visualizer</h1>
        <div class="metric-card p-3 mb-4">
             <div class="flex flex-wrap items-center gap-x-4 gap-y-2">
                 <div class="flex items-center">
                    <input type="file" id="fileInput" accept=".txt,.log" class="block w-full text-sm text-gray-500
                        file:mr-3 file:py-1.5 file:px-3
                        file:rounded-full file:border-0 file:text-sm file:font-semibold
                        file:bg-indigo-50 file:text-indigo-700 hover:file:bg-indigo-100">
                 </div>
                 <div class="flex items-center space-x-4 text-sm">
                    <div class="flex items-baseline space-x-1.5">
                        <span class="font-semibold text-gray-600">仅支持V2X调度轨迹数据格式
                        <a href="https://3ms.huawei.com/next/groups/index.html#/wiki/detail?groupId=3828267&wikiId=6571498" class="text-indigo-600 hover:underline">[思路来源] </a>
                        <a href="https://wiki.huawei.com/domains/12565/wiki/179215/WIKI202501105697774" class="text-indigo-600 hover:underline">[调度数据采集]</a>
                        </span>
                    </div>
                 </div>
                 <div class="h-6 border-l border-gray-300 mx-2"></div>

                 <div class="flex items-center space-x-4 text-sm">
                    <div class="flex items-baseline space-x-1.5">
                        <span class="font-semibold text-gray-600">Nodes:</span>
                        <span id="total-nodes-val" class="font-bold text-indigo-600">-</span>
                        <span class="text-gray-500">(<span id="filtered-nodes-val" class="font-bold text-green-600">-</span>)</span>
                    </div>
                    <div class="flex items-baseline space-x-1.5">
                        <span class="font-semibold text-gray-600">Edges:</span>
                        <span id="total-edges-val" class="font-bold text-indigo-600">-</span>
                        <span class="text-gray-500">(<span id="filtered-edges-val" class="font-bold text-green-600">-</span>)</span>
                    </div>
                     <div class="flex items-baseline space-x-1.5">
                        <span class="font-semibold text-gray-600">Switches:</span>
                        <span id="total-switches-val" class="font-bold text-indigo-600">-</span>
                        <span class="text-gray-500">(<span id="filtered-switches-val" class="font-bold text-green-600">-</span>)</span>
                    </div>
                 </div>

                <div class="h-6 border-l border-gray-300 mx-2"></div>

                 <div id="graph-controls" class="flex flex-wrap items-center space-x-2">
                    <label for="weightThreshold" class="text-sm font-medium text-gray-700 whitespace-nowrap">最小调度次数:</label>
                    <input type="number" id="weightThreshold" value="50" min="1" class="w-20 p-1.5 rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm">
                    
                    <select id="graphDirection" class="p-1.5 rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm ml-2">
                        <option value="undirected">无向图</option>
                        <option value="directed">有向图</option>
                    </select>
                    <span class="text-gray-400 mx-1">|</span>
                    
                    <input type="text" id="nodeSearch" placeholder="搜索任务名" class="w-40 p-1.5 rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm ml-2">
                </div>
             </div>
        </div>

        <div class="flex flex-col lg:flex-row gap-4">
            <div class="metric-card flex-grow lg:w-2/3">
                <div id="graph-container" class="relative">
                    <div id="placeholder" class="text-center text-gray-500 flex items-center justify-center h-full">
                        Please upload your trace data file to begin analysis.
                    </div>
                    <svg id="graph-svg"></svg>
                    <div id="tooltip"></div>
                    <button id="fullscreen-toggle" class="absolute top-2 right-2 z-10 p-1.5 bg-gray-700 bg-opacity-50 text-white rounded hover:bg-opacity-75 text-xs">
                        [ ]
                    </button>
                </div>
            </div>

            <div class="metric-card lg:w-1/4 table-container p-3">
                <div class="flex justify-end items-center mb-2">
                    <button id="resetFilterBtn" class="px-4 py-1.5 bg-gray-200 text-gray-700 text-sm font-medium rounded-lg shadow-sm hover:bg-gray-300 focus:outline-none focus:ring-2 focus:ring-gray-500 focus:ring-opacity-75">
                       <i class="fa fa-refresh mr-1"></i>Reset Filter
                    </button>
                </div>
                <div class="flex flex-col space-y-3 mb-3 mt-3 border-t pt-3"> 
                    <div class="flex items-center">
                        <label for="bfsDepthSelect" class="text-sm font-medium text-gray-700 whitespace-nowrap mr-2">BFS深度:</label>
                        <select id="bfsDepthSelect" class="p-1.5 rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm w-full"> {/* Made select full width */}
                            <option value="1">1</option>
                            <option value="2">2</option>
                            <option value="3">3</option>
                            <option value="4">4</option>
                            <option value="5" selected>5</option>
                            <option value="6">6</option>
                            <option value="7">7</option>
                            <option value="8">8</option>
                            <option value="9">9</option>
                            <option value="10">10</option>
                        </select>
                    </div>
                    <div class="flex flex-col space-y-1"> 
                        <span class="text-xs font-medium text-gray-600">颜色图例:</span>
                        <div class="flex items-center">
                            <div class="depth-level bg-orange-400"></div>
                            <span class="text-xs text-gray-600">源节点</span>
                        </div>
                        <div class="flex items-center">
                            <div class="depth-level bg-yellow-400"></div>
                            <span class="text-xs text-gray-600">1级节点</span>
                        </div>
                        <div class="flex items-center">
                            <div class="depth-level bg-green-400"></div>
                            <span class="text-xs text-gray-600">2+级节点</span>
                        </div>
                    </div>
                </div>
                <div class="overflow-x-auto">
                    <table id="links-table" class="w-full text-xs text-left text-gray-500 compact-table">
                        <thead class="text-xs text-gray-700 uppercase bg-gray-50">
                            <tr>
                                <th scope="col" class="px-3 py-2">Task A</th>
                                <th scope="col" class="px-3 py-2">Task B</th>
                                <th scope="col" class="px-3 py-2 text-right">Switches</th>
                            </tr>
                        </thead>
                        <tbody id="links-table-body">
                            <tr>
                                <td colspan="3" class="px-3 py-2 text-center">Upload a file and adjust threshold to see data.</td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const fileInput = document.getElementById('fileInput');
            // const analyzeBtn = document.getElementById('analyzeBtn'); // Removed
            const resetFilterBtn = document.getElementById('resetFilterBtn');
            const weightThresholdInput = document.getElementById('weightThreshold');
            const graphDirectionSelect = document.getElementById('graphDirection');
            const nodeSearchInput = document.getElementById('nodeSearch');
            const bfsDepthSelect = document.getElementById('bfsDepthSelect'); // Changed from bfsDepthInput
            const tooltip = d3.select("#tooltip");
            const placeholder = document.getElementById('placeholder');
            const graphControls = document.getElementById('graph-controls');
            const graphContainer = document.getElementById('graph-container');
            const fullscreenToggleBtn = document.getElementById('fullscreen-toggle'); // New

            // Updated selectors for new count display format
            const totalNodesValEl = document.getElementById('total-nodes-val');
            const filteredNodesValEl = document.getElementById('filtered-nodes-val');
            const totalEdgesValEl = document.getElementById('total-edges-val');
            const filteredEdgesValEl = document.getElementById('filtered-edges-val');
            const totalSwitchesValEl = document.getElementById('total-switches-val');
            const filteredSwitchesValEl = document.getElementById('filtered-switches-val');

            const linksTableBody = document.getElementById('links-table-body');

            let fullGraphData = { nodes: [], links: [] };
            let undirectedGraphData = { nodes: [], links: [] };
            // let currentGraphData = { nodes: [], links: [] }; // This wasn't consistently used; removing to avoid confusion
            let simulation;
            let currentHighlightedNode = null;
            let connectedNodes = new Map();
            let connectedLinks = new Set();

            // Global cache for currently rendered graph structure by drawGraph
            let currentlyDisplayedNodes = [];
            let currentlyDisplayedLinks = [];

            // 阻止图表容器的滚轮事件冒泡到页面
            graphContainer.addEventListener('wheel', (e) => {
                if (e.ctrlKey) {
                    // 如果按住Ctrl键，允许默认缩放行为
                    return;
                }
                // 否则阻止页面滚动
                e.preventDefault();
            }, { passive: false });

            // analyzeBtn.addEventListener('click', handleAnalysis); // Removed
            fileInput.addEventListener('change', handleAnalysis); // Auto-analyze on file change
            resetFilterBtn.addEventListener('click', resetGraphFilter);
            weightThresholdInput.addEventListener('input', () => {
                console.log(`Weight threshold changed to: ${weightThresholdInput.value}`);
                drawGraph();
            });
            graphDirectionSelect.addEventListener('change', () => {
                console.log(`Graph direction changed to: ${graphDirectionSelect.value}`);
                drawGraph();
            });
            nodeSearchInput.addEventListener('input', debounce(() => {
                console.log(`Search term: ${nodeSearchInput.value}`);
                drawGraph();
            }, 300));
            
            bfsDepthSelect.addEventListener('change', () => { // Changed from bfsDepthInput to bfsDepthSelect
                console.log(`BFS depth changed to: ${bfsDepthSelect.value}`);
                if (currentHighlightedNode) {
                    highlightNodeConnections(currentHighlightedNode);
                }
            });

            function handleAnalysis() {
                const file = fileInput.files[0];
                if (!file) {
                    console.warn('No file selected.');
                    fileInput.focus();
                    return;
                }

                placeholder.textContent = 'Analyzing...';
                placeholder.style.display = 'flex';
                document.getElementById('graph-svg').innerHTML = '';
                linksTableBody.innerHTML = '<tr><td colspan="3" class="px-3 py-2 text-center">Analyzing...</td></tr>';

                if (simulation) simulation.stop();

                const reader = new FileReader();
                reader.onload = (event) => {
                    const text = event.target.result;
                    fullGraphData = parseSchedData(text);
                    console.log('Parsed full graph data:', fullGraphData);
                    if (fullGraphData.nodes.length > 0) {
                        undirectedGraphData = buildUndirectedGraph(fullGraphData);
                        currentGraphData = { ...fullGraphData };
                        console.log('Built undirected graph data:', undirectedGraphData);
                        
                        placeholder.style.display = 'none';
                        updateMetrics(fullGraphData);
                        // currentNodesEl and currentEdgesEl are removed, counts updated in drawGraph
                        drawGraph();
                    } else {
                        placeholder.textContent = 'Could not parse data from file. Please check the format.';
                        linksTableBody.innerHTML = '<tr><td colspan="3" class="px-3 py-2 text-center">Could not parse data from file. Please check the format.</td></tr>';
                    }
                };
                reader.onerror = (error) => {
                    placeholder.textContent = 'Error reading file.';
                    console.error('Error reading file:', error);
                };
                reader.readAsText(file);
            }

            function updateMetrics({nodes, links}) { // This function now sets the "Total" values
                totalNodesValEl.textContent = nodes.length.toLocaleString();
                totalEdgesValEl.textContent = links.length.toLocaleString();
                const totalSwitchesCount = links.reduce((sum, link) => sum + link.weight, 0);
                totalSwitchesValEl.textContent = totalSwitchesCount.toLocaleString();

                // Initialize filtered counts to dash or 0 when new file is loaded, before first drawGraph
                filteredNodesValEl.textContent = '-';
                filteredEdgesValEl.textContent = '-';
                filteredSwitchesValEl.textContent = '-';
            }

            function parseSchedData(text) {
                const lines = text.split('\n');
                const nodeMap = new Map();
                const linkMap = new Map();
                const regex = /prev_comm=([\S]+)\s+prev_pid=\d+\s+prev_tid=([\S]+)[\s\S]*?==>\s+next_comm=([\S]+)\s+next_tid=([\S]+)/;

                for (const line of lines) {
                    const match = line.match(regex);
                    if (match) {
                        const [, prev_comm, prev_tid, next_comm, next_tid] = match;
                        const sourceId = `${prev_comm}/${prev_tid}`;
                        const targetId = `${next_comm}/${next_tid}`;

                        if (sourceId === targetId) continue;

                        if (!nodeMap.has(sourceId)) nodeMap.set(sourceId, { id: sourceId, comm: prev_comm, pid: prev_tid });
                        if (!nodeMap.has(targetId)) nodeMap.set(targetId, { id: targetId, comm: next_comm, pid: next_tid });

                        const linkKey = `${sourceId}->${targetId}`;

                        if (linkMap.has(linkKey)) {
                            linkMap.get(linkKey).weight++;
                        } else {
                            linkMap.set(linkKey, {
                                source: sourceId,
                                target: targetId,
                                weight: 1
                            });
                        }
                    }
                }

                console.log(`Parsed ${nodeMap.size} nodes and ${linkMap.size} links`);
                return {
                    nodes: Array.from(nodeMap.values()),
                    links: Array.from(linkMap.values())
                };
            }

            function buildUndirectedGraph({nodes, links}) {
                const undirectedLinkMap = new Map();
                
                links.forEach(link => {
                    const nodeIds = [link.source, link.target].sort();
                    const undirectedKey = `${nodeIds[0]}->${nodeIds[1]}`;
                    
                    if (undirectedLinkMap.has(undirectedKey)) {
                        undirectedLinkMap.get(undirectedKey).weight += link.weight;
                    } else {
                        undirectedLinkMap.set(undirectedKey, {
                            source: nodeIds[0],
                            target: nodeIds[1],
                            weight: link.weight,
                            originalLinks: [link]
                        });
                    }
                });
                
                console.log(`Built undirected graph with ${nodes.length} nodes and ${undirectedLinkMap.size} links`);
                return {
                    nodes: [...nodes],
                    links: Array.from(undirectedLinkMap.values())
                };
            }

            function drawGraph() {
                console.log('Drawing graph with current settings...');
                if (!fullGraphData.nodes || fullGraphData.nodes.length === 0) {
                    console.log('No graph data available');
                    return;
                }

                const threshold = +weightThresholdInput.value;
                const isDirected = graphDirectionSelect.value === 'directed';
                const searchTerm = nodeSearchInput.value.trim().toLowerCase();
                
                console.log(`Threshold: ${threshold}, Directed: ${isDirected}, Search: ${searchTerm || 'none'}`);
                
                const baseGraphData = isDirected ? fullGraphData : undirectedGraphData;
                
                let { nodes, links } = baseGraphData;
                
                console.log(`Starting with ${nodes.length} nodes and ${links.length} links`);
                
                if (searchTerm) {
                    const matchedNodes = nodes.filter(node => {
                        const match = node.id.toLowerCase().includes(searchTerm) || 
                            (node.comm && node.comm.toLowerCase().includes(searchTerm)) ||
                            (node.pid && node.pid.toLowerCase().includes(searchTerm));
                        console.log(`Node ${node.id}: ${match ? 'MATCH' : 'NO MATCH'}`);
                        return match;
                    });
                    
                    console.log(`Found ${matchedNodes.length} matched nodes`);
                    
                    if (matchedNodes.length === 0) {
                        console.log('No nodes matched search term');
                        nodes = [];
                        links = [];
                    } else {
                        const matchedNodeIds = new Set(matchedNodes.map(node => node.id));
                        
                        links = links.filter(link => {
                            const match = matchedNodeIds.has(link.source) || matchedNodeIds.has(link.target);
                            console.log(`Link ${link.source} -> ${link.target}: ${match ? 'MATCH' : 'NO MATCH'}`);
                            return match;
                        });
                        
                        const nodesInLinks = new Set([
                            ...links.map(link => link.source),
                            ...links.map(link => link.target)
                        ]);
                        
                        nodes = nodes.filter(node => nodesInLinks.has(node.id));
                        
                        console.log(`Filtered to ${nodes.length} nodes and ${links.length} links after search`);
                    }
                }

                const filteredLinks = links
                    .filter(link => {
                        const match = link.weight >= threshold;
                        console.log(`Link ${link.source} -> ${link.target} (weight ${link.weight}): ${match ? 'PASS' : 'FILTERED'}`);
                        return match;
                    })
                    .sort((a, b) => b.weight - a.weight);

                console.log(`After weight threshold filter: ${filteredLinks.length} links`);
                
                // 调试输出过滤后的边数据
                console.log('Filtered links:', filteredLinks);

                const fullNodeLookup = new Map();
                fullGraphData.nodes.forEach(node => {
                    fullNodeLookup.set(node.id, {
                        id: node.id,
                        comm: node.comm || node.id.split('/')[0],
                        pid: node.pid || node.id.split('/')[1]
                    });
                });

                console.log(`Full node lookup created with ${fullNodeLookup.size} entries`);

                // 更新表格
                linksTableBody.innerHTML = '';

                if (filteredLinks.length === 0) {
                    console.log('No links to display in table');
                    const row = linksTableBody.insertRow();
                    const cell = row.insertCell();
                    cell.colSpan = 3;
                    cell.textContent = 'No links meet the current threshold.';
                    cell.className = 'px-3 py-2 text-center';
                } else {
                    console.log(`Populating table with ${filteredLinks.length} links`);
                    filteredLinks.forEach(link => {
                        // 确保link.source和link.target是字符串ID
                        const sourceId = typeof link.source === 'object' ? link.source.id : link.source;
                        const targetId = typeof link.target === 'object' ? link.target.id : link.target;
                        
                        const sourceNode = fullNodeLookup.get(sourceId);
                        const targetNode = fullNodeLookup.get(targetId);
                        
                        console.log(`Table row: ${sourceId} (${sourceNode ? sourceNode.comm : 'unknown'}) -> ${targetId} (${targetNode ? targetNode.comm : 'unknown'})`);
                        
                        // 额外调试：如果节点未找到，输出更多信息
                        if (!sourceNode) {
                            console.warn(`Source node not found for ID: ${sourceId}`, link);
                        }
                        if (!targetNode) {
                            console.warn(`Target node not found for ID: ${targetId}`, link);
                        }

                        const row = linksTableBody.insertRow();
                        row.className = 'bg-white border-b hover:bg-gray-50 transition-colors';

                        const cellNodeA = row.insertCell();
                        cellNodeA.innerHTML = sourceNode ? `<span class="task-link" data-node-id="${sourceId}">${sourceNode.comm}/${sourceNode.pid}</span>` : sourceId;
                        cellNodeA.className = 'px-3 py-2 font-medium text-gray-900 whitespace-nowrap';

                        const cellNodeB = row.insertCell();
                        cellNodeB.innerHTML = targetNode ? `<span class="task-link" data-node-id="${targetId}">${targetNode.comm}/${targetNode.pid}</span>` : targetId;
                        cellNodeB.className = 'px-3 py-2';

                        const cellSwitches = row.insertCell();
                        cellSwitches.textContent = link.weight;
                        cellSwitches.className = 'px-3 py-2 font-semibold text-indigo-600 text-right';
                    });

                    // 为任务链接添加点击事件
                    document.querySelectorAll('.task-link').forEach(link => {
                        link.addEventListener('click', (e) => {
                            const nodeId = e.currentTarget.getAttribute('data-node-id');
                            highlightNodeConnections(nodeId);
                        });
                    });
                }

                // 图形渲染代码
                const container = document.getElementById('graph-container');
                const svg = d3.select("#graph-svg");

                svg.selectAll("*").remove();

                // Update displayed node and edge counts based on the data *before* simulation
                // These are the nodes and links that will be attempted to be rendered.
                filteredNodesValEl.textContent = nodes.length.toLocaleString();
                filteredEdgesValEl.textContent = filteredLinks.length.toLocaleString();
                const filteredSwitchesCount = filteredLinks.reduce((sum, link) => sum + link.weight, 0);
                filteredSwitchesValEl.textContent = filteredSwitchesCount.toLocaleString();

                // Cache the exact nodes and links being rendered for BFS in highlightNodeConnections
                currentlyDisplayedNodes = [...nodes]; // Store a copy
                currentlyDisplayedLinks = [...filteredLinks]; // Store a copy


                const width = container.clientWidth;
                const height = container.clientHeight;

                const g = svg.append("g");

                if (isDirected) {
                    svg.append("defs").append("marker")
                        .attr("id", "arrowhead")
                        .attr("viewBox", "0 0 10 10")
                        .attr("refX", 9)
                        .attr("refY", 5)
                        .attr("markerWidth", 6)
                        .attr("markerHeight", 6)
                        .attr("orient", "auto")
                        .append("path")
                        .attr("d", "M 0 0 L 10 5 L 0 10 z")
                        .attr("class", "arrowhead");
                }

                // 确保links数据格式正确
                const formattedLinks = filteredLinks.map(link => ({
                    ...link,
                    source: typeof link.source === 'object' ? link.source.id : link.source,
                    target: typeof link.target === 'object' ? link.target.id : link.target
                }));

                simulation = d3.forceSimulation(nodes)
                    .force("link", d3.forceLink(formattedLinks).id(d => d.id)
                        .strength(d => 0.1 * Math.sqrt(d.weight / (d3.max(formattedLinks, l => l.weight) || 1))))
                    .force("charge", d3.forceManyBody().strength(-400))
                    .force("center", d3.forceCenter(width / 2, height / 2))
                    .force("collide", d3.forceCollide().radius(15));

                const linkGroup = g.append("g")
                    .selectAll("g")
                    .data(formattedLinks)
                    .join("g")
                    .attr("class", "link-group");

                const linkLine = linkGroup.append("line")
                    .attr("stroke", "#999")
                    .attr("stroke-opacity", 0.6);
                    // stroke-width will be set dynamically below

                // Dynamic edge thickness logic
                if (formattedLinks.length > 0) {
                    const minWeight = d3.min(formattedLinks, l => l.weight);
                    const maxWeight = d3.max(formattedLinks, l => l.weight);

                    // Create a scale for stroke width. Adjust range for visual preference.
                    // Using a linear scale from 1px to 8px. Sqrt scale could also be an option.
                    const thicknessScale = d3.scaleLinear()
                                             .domain([minWeight, maxWeight])
                                             .range([1, 8]) // Min/max stroke width in pixels
                                             .clamp(true); // Ensure output is within range

                    linkLine.attr("stroke-width", d => thicknessScale(d.weight));
                } else {
                    linkLine.attr("stroke-width", 1); // Default if no links or all links have same weight
                }
                
                if (isDirected) {
                    linkLine.attr("marker-end", "url(#arrowhead)");
                }

                linkGroup.append("text")
                    .text(d => d.weight)
                    .attr("font-size", "10px")
                    .attr("font-family", "sans-serif")
                    .attr("fill", "#333")
                    .attr("stroke", "white")
                    .attr("stroke-width", 0.4)
                    .attr("paint-order", "stroke")
                    .style("display", "none")
                    .style("pointer-events", "none");

                linkGroup
                    .on("mouseover", function(event, d) {
                        d3.select(this).select('text').style('display', 'block');
                        tooltip.style("opacity", 1).html(`切换次数: ${d.weight}`);
                    })
                    .on("mousemove", (event) => {
                        tooltip.style("left", (event.pageX + 15) + "px")
                               .style("top", (event.pageY - 28) + "px");
                    })
                    .on("mouseout", function() {
                        d3.select(this).select('text').style('display', 'none');
                        tooltip.style("opacity", 0);
                    });

                const nodeGroup = g.append("g")
                    .selectAll("g")
                    .data(nodes)
                    .join("g")
                    .attr("class", "node");

                nodeGroup.append("circle")
                    .attr("r", 8)
                    .attr("fill", "#4f46e5")
                    .attr("stroke", "#fff")
                    .attr("stroke-width", 1.5);

                nodeGroup.append("text")
                    .text(d => `${d.comm}/${d.pid}`)
                    .attr("x", 12)
                    .attr("y", 4)
                    .attr("font-size", "12px")
                    .attr("font-family", "monospace")
                    .attr("fill", "#333")
                    .style("display", "none")
                    .style("pointer-events", "none");

                nodeGroup.on("mouseover", function(event, d) {
                        d3.select(this).select('text').style('display', 'block');
                        tooltip.style("opacity", 1).html(`任务: ${d.id}`);
                    })
                    .on("mousemove", (event) => {
                        tooltip.style("left", (event.pageX + 15) + "px")
                               .style("top", (event.pageY - 28) + "px");
                    })
                    .on("mouseout", function() {
                        d3.select(this).select('text').style('display', 'none');
                        tooltip.style("opacity", 0);
                    })
                    .on("click", function(event, d) {
                        highlightNodeConnections(d.id);
                    });

                const drag = d3.drag()
                    .on("start", (event, d) => {
                        if (!event.active) simulation.alphaTarget(0.3).restart();
                        d.fx = d.x;
                        d.fy = d.y;
                    })
                    .on("drag", (event, d) => {
                        d.fx = event.x;
                        d.fy = event.y;
                    })
                    .on("end", (event, d) => {
                        if (!event.active) simulation.alphaTarget(0);
                        d.fx = null;
                        d.fy = null;
                    });

                nodeGroup.call(drag);

                const zoom = d3.zoom()
                    .scaleExtent([0.1, 10])
                    .on("zoom", (event) => {
                        g.attr("transform", event.transform);
                    });

                svg.call(zoom);

                simulation.on("tick", () => {
                    linkGroup.select("line")
                        .attr("x1", d => d.source.x)
                        .attr("y1", d => d.source.y)
                        .attr("x2", d => d.target.x)
                        .attr("y2", d => d.target.y);

                    linkGroup.select("text")
                        .attr("x", d => (d.source.x + d.target.x) / 2)
                        .attr("y", d => (d.source.y + d.target.y) / 2);

                    nodeGroup.attr("transform", d => `translate(${d.x},${d.y})`);
                });
                
                console.log('Graph drawing completed');
                
                // 如果有当前高亮节点，重新应用高亮
                if (currentHighlightedNode) {
                    highlightNodeConnections(currentHighlightedNode);
                }
            }

            function highlightNodeConnections(nodeId) {
                const currentBfsDepth = bfsDepthSelect.value; // Use new select element
                console.log(`Highlighting connections for node: ${nodeId} with BFS depth: ${currentBfsDepth}`);
                
                // 重置之前的高亮状态
                d3.selectAll('.node circle').classed('node-highlighted', false).classed('node-dimmed', false);
                d3.selectAll('.link-group line').classed('link-highlighted', false).classed('link-dimmed', false);
                d3.selectAll('.node text').classed('highlighted-node-text', false);
                
                // 如果点击同一个节点，取消高亮
                if (currentHighlightedNode === nodeId) {
                    currentHighlightedNode = null;
                    connectedNodes.clear();
                    connectedLinks.clear();
                    document.querySelectorAll('.task-link').forEach(link => {
                        link.classList.remove('font-bold', 'text-indigo-700');
                    });
                    // When un-highlighting, revert to counts from the main drawGraph function
                    // This typically means re-calling drawGraph or ensuring its last calculated counts are displayed.
                    // For simplicity here, we'll call drawGraph to reset view and counts.
                    drawGraph();
                    return;
                }
                
                currentHighlightedNode = nodeId;
                connectedNodes.clear();
                connectedLinks.clear();
                
                const isDirected = graphDirectionSelect.value === 'directed'; // Keep for link directionality if needed in BFS
                const maxDepth = +bfsDepthSelect.value;

                // Use the cached currently displayed nodes and links for BFS
                const nodesForBfs = currentlyDisplayedNodes;
                const linksForBfs = currentlyDisplayedLinks;

                // Check if the selected node for highlighting even exists in the currently displayed nodes.
                const startNodeInDisplayed = nodesForBfs.find(n => n.id === nodeId);
                if (!startNodeInDisplayed) {
                    console.warn(`Node ${nodeId} selected for highlighting but not found in currently displayed nodes. Aborting highlight.`);
                    // Reset to a clean state if the start node isn't even visible.
                    // This might happen if filters changed between click and processing, though unlikely with current setup.
                    d3.selectAll('.node circle').classed('node-highlighted', false).classed('node-dimmed', false).attr('fill', '#4f46e5');
                    d3.selectAll('.link-group line').classed('link-highlighted', false).classed('link-dimmed', false);
                    d3.selectAll('.node text').classed('highlighted-node-text', false);
                    // Ensure counts reflect the current general view if highlight aborts
                    displayedNodesCountEl.textContent = currentlyDisplayedNodes.length.toLocaleString();
                    displayedEdgesCountEl.textContent = currentlyDisplayedLinks.length.toLocaleString();
                    currentHighlightedNode = null; // Clear highlight state
                    return;
                }
                
                const queue = [{id: nodeId, depth: 0}];
                connectedNodes.set(nodeId, 0); // Map of {id: depth}
                
                let head = 0; // Using simple array queue, head index to simulate shift() for performance
                while(head < queue.length) {
                    const {id: currentId, depth: currentDepth} = queue[head++];
                    
                    if (currentDepth >= maxDepth) continue;
                    
                    linksForBfs.forEach(link => {
                        // Ensure link source/target are IDs, not objects, for comparison
                        const linkSourceId = (typeof link.source === 'object') ? link.source.id : link.source;
                        const linkTargetId = (typeof link.target === 'object') ? link.target.id : link.target;

                        let neighborId = null;

                        if (linkSourceId === currentId) {
                            neighborId = linkTargetId;
                        } else if (!isDirected && linkTargetId === currentId) {
                            neighborId = linkSourceId;
                        }
                        // For directed graphs, if link.target === currentId, it's an incoming link.
                        // The current BFS explores "outgoing" from nodeId. If "incoming" also desired, logic here would change.

                        if (neighborId) {
                            // Check if neighbor is in the set of currently displayed nodes
                            const neighborInDisplayed = nodesForBfs.find(n => n.id === neighborId);
                            if (!neighborInDisplayed) return; // Skip if neighbor isn't currently visible

                            const linkKey = `${linkSourceId}-${linkTargetId}`; // Canonical key for the link direction in BFS

                            if (!connectedNodes.has(neighborId) || connectedNodes.get(neighborId) > currentDepth + 1) {
                                connectedNodes.set(neighborId, currentDepth + 1);
                                queue.push({id: neighborId, depth: currentDepth + 1});
                                connectedLinks.add(linkKey);
                            } else if (connectedNodes.has(neighborId) && (connectedNodes.get(neighborId) === currentDepth + 1 || currentDepth < connectedNodes.get(neighborId))) {
                                // If already visited but this path is shorter or same (for multi-path to same node within depth)
                                // ensure link is added if it's part of *any* valid path to a connected node
                                connectedLinks.add(linkKey);
                            }
                        }
                    });
                }
                console.log(`BFS from ${nodeId} (depth ${maxDepth}) found ${connectedNodes.size} nodes and ${connectedLinks.size} links within the currently displayed graph.`);
                
                // 更新节点样式
                d3.selectAll('.node circle').each(function(d) {
                    if (connectedNodes.has(d.id)) {
                        const depth = connectedNodes.get(d.id);
                        let fillColor;
                        
                        // 根据深度设置不同的颜色
                        if (depth === 0) {
                            fillColor = '#f59e0b'; // 源节点
                        } else if (depth === 1) {
                            fillColor = '#eab308'; // 一级节点
                        } else {
                            fillColor = '#22c55e'; // 二级及以上节点
                        }
                        
                        d3.select(this)
                            .attr('fill', fillColor)
                            .classed('node-highlighted', true)
                            .classed('node-dimmed', false);
                            
                        // 显示高亮节点的文本
                        d3.select(this.parentNode).select('text')
                            .classed('highlighted-node-text', true);
                    } else {
                        d3.select(this).classed('node-highlighted', false).classed('node-dimmed', true);
                    }
                });
                
                // 更新边样式
                d3.selectAll('.link-group line').each(function(d) {
                    const linkKey = `${d.source.id}-${d.target.id}`;
                    if (connectedLinks.has(linkKey) || connectedLinks.has(`${d.target.id}-${d.source.id}`)) {
                        d3.select(this).classed('link-highlighted', true).classed('link-dimmed', false);
                    } else {
                        d3.select(this).classed('link-highlighted', false).classed('link-dimmed', true);
                    }
                });
                
                // 更新表格中的高亮
                document.querySelectorAll('.task-link').forEach(link => {
                    if (link.getAttribute('data-node-id') === nodeId) {
                        link.classList.add('font-bold', 'text-indigo-700');
                    } else {
                        link.classList.remove('font-bold', 'text-indigo-700');
                    }
                });
                
                // 更新当前显示的节点数和边数 (Filtered values)
                filteredNodesValEl.textContent = connectedNodes.size.toLocaleString();
                filteredEdgesValEl.textContent = connectedLinks.size.toLocaleString();
                // For switches, sum the weights of the connectedLinks
                let highlightedSwitchesCount = 0;
                const allLinksForWeightLookup = currentlyDisplayedLinks; // Or merge fullGraphData.links if original weights needed and not on currentlyDisplayedLinks
                connectedLinks.forEach(linkKey => {
                    // linkKey is sourceId-targetId. Need to find the link object to get its weight.
                    // This is a bit inefficient if linksForBfs is large.
                    // Consider if connectedLinks should store link objects or if weights need to be summed differently.
                    // For now, assuming linkKey is sufficient if currentlyDisplayedLinks contains these keys.
                    const parts = linkKey.split('-');
                    const sourceId = parts[0]; // This assumes no hyphens in IDs themselves
                    const targetId = parts.slice(1).join('-'); // To handle hyphens in target ID

                    const actualLink = allLinksForWeightLookup.find(l =>
                        ((typeof l.source === 'object' ? l.source.id : l.source) === sourceId &&
                         (typeof l.target === 'object' ? l.target.id : l.target) === targetId) ||
                        (!isDirected && (typeof l.source === 'object' ? l.source.id : l.source) === targetId &&
                         (typeof l.target === 'object' ? l.target.id : l.target) === sourceId) // check reverse for undirected
                    );
                    if (actualLink) {
                        highlightedSwitchesCount += actualLink.weight;
                    }
                });
                filteredSwitchesValEl.textContent = highlightedSwitchesCount.toLocaleString();
            }

            function resetGraphFilter() {
                console.log('Resetting graph filter');
                
                currentHighlightedNode = null; // Clear any highlighted node state
                connectedNodes.clear();
                connectedLinks.clear();

                // Reset input fields to defaults if desired, or simply redraw
                // weightThresholdInput.value = "50"; // Or initial default
                // nodeSearchInput.value = "";
                // graphDirectionSelect.value = "undirected"; // Or initial default
                // bfsDepthSelect.value = "5"; // Or initial default

                // Redraw the graph with original filters/no filters.
                // This will also update displayedNodesCountEl and displayedEdgesCountEl.
                drawGraph();
                
                // The d3 selections for highlighting are reset within drawGraph or highlightNodeConnections(null)
                // If drawGraph() doesn't fully reset all visual states (e.g. table highlights), do it here:
                document.querySelectorAll('.task-link').forEach(link => {
                    link.classList.remove('font-bold', 'text-indigo-700');
                });
            }

            function debounce(func, delay) {
                let timeout;
                return function() {
                    const context = this;
                    const args = arguments;
                    clearTimeout(timeout);
                    timeout = setTimeout(() => func.apply(context, args), delay);
                };
            }

            // Fullscreen API handling
            function toggleFullscreen() {
                if (!document.fullscreenElement &&
                    !document.mozFullScreenElement &&
                    !document.webkitFullscreenElement &&
                    !document.msFullscreenElement) { // Not in fullscreen
                    if (graphContainer.requestFullscreen) {
                        graphContainer.requestFullscreen();
                    } else if (graphContainer.mozRequestFullScreen) { /* Firefox */
                        graphContainer.mozRequestFullScreen();
                    } else if (graphContainer.webkitRequestFullscreen) { /* Chrome, Safari & Opera */
                        graphContainer.webkitRequestFullscreen();
                    } else if (graphContainer.msRequestFullscreen) { /* IE/Edge */
                        graphContainer.msRequestFullscreen();
                    }
                } else { // In fullscreen
                    if (document.exitFullscreen) {
                        document.exitFullscreen();
                    } else if (document.mozCancelFullScreen) { /* Firefox */
                        document.mozCancelFullScreen();
                    } else if (document.webkitExitFullscreen) { /* Chrome, Safari & Opera */
                        document.webkitExitFullscreen();
                    } else if (document.msExitFullscreen) { /* IE/Edge */
                        document.msExitFullscreen();
                    }
                }
            }

            fullscreenToggleBtn.addEventListener('click', toggleFullscreen);

            function updateFullscreenButton() {
                const isGraphFullscreen = document.fullscreenElement === graphContainer ||
                                       document.mozFullScreenElement === graphContainer ||
                                       document.webkitFullscreenElement === graphContainer ||
                                       document.msFullscreenElement === graphContainer;
                if (isGraphFullscreen) {
                    fullscreenToggleBtn.textContent = 'X'; // Exit fullscreen icon
                } else {
                    fullscreenToggleBtn.textContent = '[ ]'; // Enter fullscreen icon
                }
                return isGraphFullscreen;
            }

            function handleFullscreenChange() {
                const isGraphNowFullscreen = updateFullscreenButton();
                console.log("Fullscreen state changed. Graph is fullscreen:", isGraphNowFullscreen);

                // Trigger a redraw to adapt to new dimensions
                if (fullGraphData.nodes && fullGraphData.nodes.length > 0) {
                    setTimeout(() => {
                        // If drawGraph reinitializes simulation, that's fine.
                        // If it doesn't, we might need to update forces here.
                        // drawGraph() already recalculates width/height and re-centers.
                        drawGraph();

                        // Ensure simulation adapts if it's already running
                        if (simulation && simulation.nodes().length > 0) {
                             const newWidth = graphContainer.clientWidth;
                             const newHeight = graphContainer.clientHeight;
                             simulation.force("center", d3.forceCenter(newWidth / 2, newHeight / 2));
                             // simulation.alpha(0.3).restart(); // Reheat simulation may or may not be desired on every resize
                        }
                        console.log("Graph redraw triggered due to fullscreen change.");
                    }, 150); // Delay to allow DOM to settle
                }
            }

            document.addEventListener('fullscreenchange', handleFullscreenChange);
            document.addEventListener('mozfullscreenchange', handleFullscreenChange);
            document.addEventListener('webkitfullscreenchange', handleFullscreenChange);
            document.addEventListener('msfullscreenchange', handleFullscreenChange);

            // Initial button state update
            updateFullscreenButton();

        });
    </script>
</body>
</html>    
