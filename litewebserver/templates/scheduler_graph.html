<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Scheduler Trace Visualizer</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            background-color: #f8f9fa;
        }

        .metric-card {
            background-color: white;
            border-radius: 0.75rem;
            box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
        }

        #graph-container {
            height: 100vh;
            position: relative;
            cursor: move;
            overflow: hidden;
        }

        svg {
            width: 100%;
            height: 100%;
            display: block;
        }

        .node, .link-group {
            cursor: pointer;
        }

        #tooltip {
            position: absolute;
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 6px 10px;
            border-radius: 4px;
            font-size: 0.85rem;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
        }

        .arrowhead {
            fill: #333; /* Changed for better visibility */
        }

        .table-container {
            max-height: 100vh;
            overflow-y: auto;
        }

        .compact-table th, .compact-table td {
            padding: 0.3rem 0.5rem;
        }

        .node-highlighted {
            fill: #f59e0b !important;
            r: 10 !important;
            stroke: #b45309 !important;
            stroke-width: 2px !important;
        }

        .node-dimmed {
            fill: #d1d5db !important;
            r: 5 !important;
            opacity: 0.5 !important;
        }

        .link-highlighted {
            stroke: #f59e0b !important;
            /* stroke-width will be set by JS dynamically or to a fixed value */
            stroke-opacity: 0.8 !important;
        }

        .link-dimmed {
            stroke: #e5e7eb !important;
            stroke-width: 0.5px !important;
            stroke-opacity: 0.3 !important;
        }

        .task-link {
            cursor: pointer;
            color: #4f46e5;
            text-decoration: underline;
        }

        .task-link:hover {
            color: #1e40af;
        }

        .filter-active {
            background-color: #f3f4f6;
        }

        .highlighted-node-text {
            display: block !important;
            font-weight: bold !important;
            fill: #b45309 !important;
        }

        .depth-level {
            display: inline-block;
            width: 15px;
            height: 15px;
            border-radius: 50%;
            margin-right: 5px;
        }
    </style>
</head>
<body>

    <div class="flex flex-col w-full p-4 md:p-6 lg:p-8 bg-gray-50">
        <h1 class="text-3xl font-bold text-gray-800 mb-6 text-center">RTOS V2X Scheduler Trace Graph Visualizer</h1>
        <div class="metric-card p-3 mb-4">
             <div class="flex flex-wrap items-center gap-x-4 gap-y-2">
                 <div class="flex items-center">
                    <label for="traceTypeSelect" class="text-sm font-medium text-gray-700 mr-2 whitespace-nowrap">Trace Type:</label>
                    <select id="traceTypeSelect" class="p-1.5 rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm mr-3">
                        <option value="wakeup" selected>任务唤醒 (Task Wakeup)</option>
                        <option value="sched_switch">调度切换 (Sched Switch)</option>
                    </select>
                 </div>
                 <div class="flex items-center">
                    <input type="file" id="fileInput" accept=".txt,.log" class="block w-full text-sm text-gray-500
                        file:mr-3 file:py-1.5 file:px-3
                        file:rounded-full file:border-0 file:text-sm file:font-semibold
                        file:bg-indigo-50 file:text-indigo-700 hover:file:bg-indigo-100">
                 </div>
                 <div class="flex items-center space-x-4 text-sm">
                    <div class="flex items-baseline space-x-1.5">
                        <span class="font-semibold text-gray-600">仅支持V2X调度轨迹数据格式
                        <a href="https://3ms.huawei.com/next/groups/index.html#/wiki/detail?groupId=3828267&wikiId=6571498" class="text-indigo-600 hover:underline">[思路来源] </a>
                        <a href="https://wiki.huawei.com/domains/12565/wiki/179215/WIKI202501105697774" class="text-indigo-600 hover:underline">[调度数据采集]</a>
                        </span>
                    </div>
                 </div>
                 <div class="h-6 border-l border-gray-300 mx-2"></div>

                 <div class="flex items-center space-x-4 text-sm">
                    <div class="flex items-baseline space-x-1.5">
                        <span class="font-semibold text-gray-600">Nodes:</span>
                        <span id="total-nodes-val" class="font-bold text-indigo-600">-</span>
                        <span class="text-gray-500">(<span id="filtered-nodes-val" class="font-bold text-green-600">-</span>)</span>
                    </div>
                    <div class="flex items-baseline space-x-1.5">
                        <span class="font-semibold text-gray-600">Edges:</span>
                        <span id="total-edges-val" class="font-bold text-indigo-600">-</span>
                        <span class="text-gray-500">(<span id="filtered-edges-val" class="font-bold text-green-600">-</span>)</span>
                    </div>
                     <div class="flex items-baseline space-x-1.5">
                        <span class="font-semibold text-gray-600">Switches:</span>
                        <span id="total-switches-val" class="font-bold text-indigo-600">-</span>
                        <span class="text-gray-500">(<span id="filtered-switches-val" class="font-bold text-green-600">-</span>)</span>
                    </div>
                 </div>

                <div class="h-6 border-l border-gray-300 mx-2"></div>

                 <div id="graph-controls" class="flex flex-wrap items-center space-x-2">
                    <label for="weightThreshold" class="text-sm font-medium text-gray-700 whitespace-nowrap">最小调度次数:</label>
                    <input type="number" id="weightThreshold" value="50" min="1" class="w-20 p-1.5 rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm">
                    
                    <select id="graphDirection" class="p-1.5 rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm ml-2">
                        <option value="undirected">无向图</option>
                        <option value="directed">有向图</option>
                    </select>
                    <span class="text-gray-400 mx-1">|</span>
                    
                    <input type="text" id="nodeSearch" placeholder="搜索任务名" class="w-40 p-1.5 rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm ml-2">
                </div>
             </div>
        </div>

        <div class="flex flex-col lg:flex-row gap-4">
            <div class="metric-card flex-grow lg:w-2/3">
                <div id="graph-container" class="relative">
                    <div id="placeholder" class="text-center text-gray-500 flex items-center justify-center h-full">
                        Please upload your trace data file to begin analysis.
                    </div>
                    <svg id="graph-svg"></svg>
                    <div id="tooltip"></div>
                    <button id="fullscreen-toggle" class="absolute top-2 right-2 z-10 p-1.5 bg-gray-700 bg-opacity-50 text-white rounded hover:bg-opacity-75 text-xs">
                        [ ]
                    </button>
                </div>
            </div>


            <div class="metric-card lg:w-1/4 table-container p-3">
                <div class="flex flex-row items-center justify-between space-x-2 mb-2 pt-1 border-t mt-2"> 

                    <div class="flex items-center">
                        <label for="bfsDepthSelect" class="text-xs font-medium text-gray-600 mr-1 whitespace-nowrap">BFS:</label>
                        <select id="bfsDepthSelect" class="p-1 text-xs rounded border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500" style="min-width: 45px; max-width:55px;">
                            <option value="1">1</option>
                            <option value="2">2</option>
                            <option value="3">3</option>
                            <option value="4">4</option>
                            <option value="5" selected>5</option>
                            <option value="6">6</option>
                            <option value="7">7</option>
                            <option value="8">8</option>
                            <option value="9">9</option>
                            <option value="10">10</option>
                        </select>
                    </div>

                    <div class="flex items-center space-x-1">
                        <span class="text-xs font-medium text-gray-600 hidden sm:inline">Legend:</span>

                        <div class="flex items-center" title="Source Node">
                            <div class="depth-level bg-orange-400 w-2.5 h-2.5"></div> <span class="text-xs text-gray-500 ml-0.5 hidden md:inline">S</span>
                        </div>
                        <div class="flex items-center" title="Level 1">
                            <div class="depth-level bg-yellow-400 w-2.5 h-2.5"></div> <span class="text-xs text-gray-500 ml-0.5 hidden md:inline">L1</span>
                        </div>
                        <div class="flex items-center" title="Level 2+">
                            <div class="depth-level bg-green-400 w-2.5 h-2.5"></div> <span class="text-xs text-gray-500 ml-0.5 hidden md:inline">L2+</span>
                        </div>
                    </div>

                    <button id="resetFilterBtn" class="px-2 py-1 bg-gray-200 text-gray-700 text-xs font-medium rounded shadow-sm hover:bg-gray-300 whitespace-nowrap">
                       Reset
                    </button>
                </div>
                <div class="overflow-x-auto">
                    <table id="links-table" class="w-full text-xs text-left text-gray-500 compact-table">
                        <thead class="text-xs text-gray-700 uppercase bg-gray-50">
                            <tr>
                                <th scope="col" class="px-3 py-2">Task A</th>
                                <th scope="col" class="px-3 py-2">Task B</th>
                                <th scope="col" class="px-3 py-2 text-right">Switches</th>
                            </tr>
                        </thead>
                        <tbody id="links-table-body">
                            <tr>
                                <td colspan="3" class="px-3 py-2 text-center">Upload a file and adjust threshold to see data.</td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const fileInput = document.getElementById('fileInput');
            // const analyzeBtn = document.getElementById('analyzeBtn'); // Removed
            const resetFilterBtn = document.getElementById('resetFilterBtn');
            const weightThresholdInput = document.getElementById('weightThreshold');
            const graphDirectionSelect = document.getElementById('graphDirection');
            const nodeSearchInput = document.getElementById('nodeSearch');
            const bfsDepthSelect = document.getElementById('bfsDepthSelect'); // Changed from bfsDepthInput
            const tooltip = d3.select("#tooltip");
            const placeholder = document.getElementById('placeholder');
            const graphControls = document.getElementById('graph-controls');
            const graphContainer = document.getElementById('graph-container');
            const fullscreenToggleBtn = document.getElementById('fullscreen-toggle'); // New

            // Updated selectors for new count display format
            const totalNodesValEl = document.getElementById('total-nodes-val');
            const filteredNodesValEl = document.getElementById('filtered-nodes-val');
            const totalEdgesValEl = document.getElementById('total-edges-val');
            const filteredEdgesValEl = document.getElementById('filtered-edges-val');
            const totalSwitchesValEl = document.getElementById('total-switches-val');
            const filteredSwitchesValEl = document.getElementById('filtered-switches-val');

            const linksTableBody = document.getElementById('links-table-body');

            let fullGraphData = { nodes: [], links: [] };
            let undirectedGraphData = { nodes: [], links: [] };
            // let currentGraphData = { nodes: [], links: [] }; // This wasn't consistently used; removing to avoid confusion
            let simulation;
            let currentHighlightedNode = null;
            let connectedNodes = new Map();
            let connectedLinks = new Set();
            let g; // Declare g here for wider scope, will be assigned in drawGraph

            // Global cache for currently rendered graph structure by drawGraph
            let currentlyDisplayedNodes = [];
            let currentlyDisplayedLinks = [];
            let lastZoomTransform = null; // To store zoom state
            let highlightedLinkFromTable = null; // For Task 1: Edge Highlighting from Table
            let bfsActiveNode = null; // 新增全局变量

            let comm_pid_tid_list = []; // Stores {comm, pid, tid} for PID/PID_name lookup

            // Helper function to create a thickness scale for links
            function createThicknessScale(linksData, minPx = 1, maxPx = 8) {
                if (!linksData || linksData.length === 0) {
                    return () => (minPx + maxPx) / 2; // Default for empty link sets
                }

                const weights = linksData.map(l => l.weight).filter(w => w > 0); // Filter out non-positive weights for scale domain

                if (weights.length === 0) { // All links had zero or negative weight or were filtered
                    return () => minPx; // Default to minPx if no positive weights
                }

                const minWeight = d3.min(weights);
                const maxWeight = d3.max(weights);

                // This case should ideally be caught by weights.length === 0 if min/max are undefined
                if (minWeight === undefined || maxWeight === undefined) {
                    return () => (minPx + maxPx) / 2;
                }

                if (minWeight === maxWeight) {
                    // If all positive weights are the same, use a thickness in the middle of the range.
                    return () => (minPx + maxPx) / 2;
                }

                // Use d3.scalePow().exponent(3) for thickness proportional to weight^3.
                return d3.scalePow()
                         .exponent(3)
                         .domain([minWeight, maxWeight])
                         .range([minPx, maxPx])
                         .clamp(true);
            }


            // 阻止图表容器的滚轮事件冒泡到页面
            graphContainer.addEventListener('wheel', (e) => {
                if (e.ctrlKey) {
                    // 如果按住Ctrl键，允许默认缩放行为
                    return;
                }
                // 否则阻止页面滚动
                e.preventDefault();
            }, { passive: false });

            // analyzeBtn.addEventListener('click', handleAnalysis); // Removed
            fileInput.addEventListener('change', handleAnalysis); // Auto-analyze on file change
            resetFilterBtn.addEventListener('click', resetGraphFilter);
            weightThresholdInput.addEventListener('input', () => {
                console.log(`Weight threshold changed to: ${weightThresholdInput.value}`);
                drawGraph();
            });
            graphDirectionSelect.addEventListener('change', () => {
                console.log(`Graph direction changed to: ${graphDirectionSelect.value}`);
                drawGraph();
            });
            nodeSearchInput.addEventListener('input', debounce(() => {
                console.log(`Search term: ${nodeSearchInput.value}`);
                drawGraph();
            }, 300));
            
            bfsDepthSelect.addEventListener('change', () => { // Changed from bfsDepthInput to bfsDepthSelect
                console.log(`BFS depth changed to: ${bfsDepthSelect.value}`);
                if (currentHighlightedNode) {
                    highlightNodeConnections(currentHighlightedNode);
                }
            });

            function handleAnalysis() {
                const file = fileInput.files[0];
                if (!file) {
                    console.warn('No file selected.');
                    fileInput.focus();
                    return;
                }

                placeholder.textContent = 'Analyzing...';
                placeholder.style.display = 'flex';
                document.getElementById('graph-svg').innerHTML = '';
                linksTableBody.innerHTML = '<tr><td colspan="3" class="px-3 py-2 text-center">Analyzing...</td></tr>';

                if (simulation) simulation.stop();

                const reader = new FileReader();
                reader.onload = (event) => {
                    const text = event.target.result;
                    fullGraphData = parseSchedData(text);
                    console.log('Parsed full graph data:', fullGraphData);
                    if (fullGraphData.nodes.length > 0) {
                        undirectedGraphData = buildUndirectedGraph(fullGraphData);
                        currentGraphData = { ...fullGraphData };
                        console.log('Built undirected graph data:', undirectedGraphData);
                        
                        placeholder.style.display = 'none';
                        updateMetrics(fullGraphData);
                        // currentNodesEl and currentEdgesEl are removed, counts updated in drawGraph
                        drawGraph();
                    } else {
                        placeholder.textContent = 'Could not parse data from file. Please check the format.';
                        linksTableBody.innerHTML = '<tr><td colspan="3" class="px-3 py-2 text-center">Could not parse data from file. Please check the format.</td></tr>';
                    }
                };
                reader.onerror = (error) => {
                    placeholder.textContent = 'Error reading file.';
                    console.error('Error reading file:', error);
                };
                reader.readAsText(file);
            }

            function updateMetrics({nodes, links}) { // This function now sets the "Total" values
                totalNodesValEl.textContent = nodes.length.toLocaleString();
                totalEdgesValEl.textContent = links.length.toLocaleString();
                const totalSwitchesCount = links.reduce((sum, link) => sum + link.weight, 0);
                totalSwitchesValEl.textContent = totalSwitchesCount.toLocaleString();

                // Initialize filtered counts to dash or 0 when new file is loaded, before first drawGraph
                filteredNodesValEl.textContent = '-';
                filteredEdgesValEl.textContent = '-';
                filteredSwitchesValEl.textContent = '-';
            }

            function parseSchedData(text) {
                let lines = text.split('\n').filter(line => line.trim() !== ''); // Filter out empty lines

                // Helper function to extract timestamp
                const getTimestamp = (line) => {
                    const match = line.match(/^\[(\d+\.\d+)\].*/);
                    if (match) {
                        return parseFloat(match[1]);
                    }
                    return null; // Or handle error/default
                };

                // Sort lines by timestamp
                lines.sort((a, b) => {
                    const tsA = getTimestamp(a);
                    const tsB = getTimestamp(b);
                    if (tsA === null || tsB === null) return 0; // Should not happen with valid data
                    return tsA - tsB;
                });

                const nodeMap = new Map();
                const linkMap = new Map();
                const traceType = document.getElementById('traceTypeSelect').value;
                comm_pid_tid_list = []; // Reset global list for new parse
                console.log("comm_pid_tid_list initialized/reset.");

                // Define regexes
                // sched_switch: prev_comm=1 prev_pid=2 prev_tid=3 ==> next_comm=4 next_tid=5
                const regex_sched_switch = /prev_comm=([\S]+)\s+prev_pid=(\d+)\s+prev_tid=([\S]+)[\s\S]*?==>\s+next_comm=([\S]+)\s+next_tid=([\S]+)/;
                // wakeup: next_comm=1 next_tid=2 prev_comm=3 prev_tid=4
                const regex_wakeup = /next_comm=([^\s]+).*?next_tid=(\d+).*?prev_comm=([^\s]+).*?prev_tid=(\d+)/;

                // New regex for IRQ and sched_wakeup processing
                const regex_irq = /\[irq\]\[cpu=(\d+)\](?:\[seq=\d+\])?\s+irqno=(\d+)/;
                const regex_sched_wakeup_detail = /\[sched_wakeup\]\[cpu=(\d+)\]comm=([^\s]+)\s+pid=(\d+)/;

                let last_irq_context_per_cpu = {}; // Stores { cpu_id: irq_no }

                let currentRegex;
                // Indices for extracting s_comm, s_tid, t_comm, t_tid for link creation
                let s_comm_idx, s_tid_idx, t_comm_idx, t_tid_idx;
                // Indices for extracting prev_comm, prev_pid, prev_tid for comm_pid_tid_list
                let line_prev_comm_idx, line_prev_pid_idx, line_prev_tid_idx;

                if (traceType === 'sched_switch') {
                    currentRegex = regex_sched_switch;
                    // Groups for sched_switch: 1:prev_comm, 2:prev_pid, 3:prev_tid, 4:next_comm, 5:next_tid
                    s_comm_idx = 1;         // prev_comm is source for the switch event
                    s_tid_idx = 3;          // prev_tid is source for the switch event
                    t_comm_idx = 4;         // next_comm is target for the switch event
                    t_tid_idx = 5;          // next_tid is target for the switch event

                    line_prev_comm_idx = 1; // prev_comm from the line
                    line_prev_pid_idx = 2;  // prev_pid from the line
                    line_prev_tid_idx = 3;  // prev_tid from the line
                    console.log("Parsing with sched_switch regex");
                } else { // Default to 'wakeup'
                    currentRegex = regex_wakeup;
                    // Groups for wakeup: 1:next_comm (target), 2:next_tid (target), 3:prev_comm (source), 4:prev_tid (source)
                    s_comm_idx = 3;         // prev_comm (waker) is source for wakeup event
                    s_tid_idx = 4;          // prev_tid (waker) is source for wakeup event
                    t_comm_idx = 1;         // next_comm (woken) is target for wakeup event
                    t_tid_idx = 2;          // next_tid (woken) is target for wakeup event

                    line_prev_comm_idx = 3; // This is the 'prev_comm' mentioned in the wakeup log line (the waker)
                    line_prev_tid_idx = 4;  // This is the 'prev_tid' mentioned in the wakeup log line (the waker's tid)
                                            // line_prev_pid_idx will be handled specially for wakeup
                    console.log("Parsing with wakeup regex");
                }

                for (const line of lines) {
                    // IRQ processing logic
                    const irq_match = line.match(regex_irq);
                    if (irq_match) {
                        const irq_cpu_val = irq_match[1];
                        const irq_no_val = irq_match[2];
                        last_irq_context_per_cpu[irq_cpu_val] = irq_no_val;
                        // console.log(`IRQ detected: cpu=${irq_cpu_val}, irqno=${irq_no_val}. Updated context for CPU ${irq_cpu_val}:`, last_irq_context_per_cpu);
                    }

                    const sched_wakeup_match = line.match(regex_sched_wakeup_detail);
                    if (sched_wakeup_match) {
                        const wakeup_cpu = sched_wakeup_match[1];
                        const wakeup_comm = sched_wakeup_match[2];
                        const wakeup_pid = sched_wakeup_match[3];

                        const relevant_irq_no = last_irq_context_per_cpu[wakeup_cpu];

                        // console.log(`Sched_wakeup detected: cpu=${wakeup_cpu}, comm=${wakeup_comm}, pid=${wakeup_pid}. IRQ context for this CPU: ${relevant_irq_no}`);

                        if (relevant_irq_no) { // If an IRQ was recorded for this CPU
                            // console.log(`IRQ-triggered wakeup on CPU ${wakeup_cpu}. Relevant IRQ No for this CPU: ${relevant_irq_no}`);
                            const source_id = `irqno_${relevant_irq_no}`;
                            const target_id = `${wakeup_comm}/${wakeup_pid}`;

                            if (!nodeMap.has(source_id)) {
                                nodeMap.set(source_id, { id: source_id, comm: `irqno_${relevant_irq_no}`, pid: relevant_irq_no });
                                // console.log(`Added IRQ node: ${source_id}`);
                            }
                            if (!nodeMap.has(target_id)) {
                                nodeMap.set(target_id, { id: target_id, comm: wakeup_comm, pid: wakeup_pid });
                                // console.log(`Added woken task node (from IRQ context): ${target_id}`);
                            }

                            const linkKey = `${source_id}->${target_id}`;
                            if (linkMap.has(linkKey)) {
                                linkMap.get(linkKey).weight++;
                            } else {
                                linkMap.set(linkKey, {
                                    source: source_id,
                                    target: target_id,
                                    weight: 1
                                });
                            }
                            // console.log(`Added/updated link from IRQ: ${linkKey}`);

                            // Decision: Should the IRQ context be cleared after use?
                            // The problem: "如果相邻的下一行还是[irq]，则覆盖上一个相邻行的[irq]中记录的"
                            // This implies IRQ context persists until overwritten by another IRQ on the same CPU.
                            // So, we do not clear `last_irq_context_per_cpu[wakeup_cpu]` here.
                        }
                    }

                    // Existing sched_switch / generic wakeup parsing logic
                    const match = line.match(currentRegex);
                    if (match) {
                        const current_line_prev_comm = match[line_prev_comm_idx];
                        const current_line_prev_tid = match[line_prev_tid_idx];
                        let current_line_prev_pid;

                        if (traceType === 'sched_switch') {
                            current_line_prev_pid = match[line_prev_pid_idx];
                        } else { // wakeup
                            // Assumption: For wakeup, if prev_pid is not in logs, use prev_tid as prev_pid.
                            current_line_prev_pid = current_line_prev_tid; // Placeholder
                        }

                        // Manage comm_pid_tid_list
                        // "对每一行数据，记录prev_comm、prev_pid、prev_tid的关系数据"
                        // "当prev_pid == prev_tid，将comm_pid_tid结构体链表中prev_comm更新为当前的prev_comm。"
                        // This means we find an entry by prev_tid, and if pid==tid, we update its comm.
                        // If no entry for prev_tid exists, we add one.

                        let entry = comm_pid_tid_list.find(e => e.tid === current_line_prev_tid);
                        if (entry) {
                            // Entry for this TID exists. Update its comm if current line indicates pid==tid.
                            if (current_line_prev_pid && current_line_prev_tid && current_line_prev_pid.toString() === current_line_prev_tid.toString()) {
                                entry.comm = current_line_prev_comm;
                                // It's also possible the PID wasn't known correctly before, so update it too.
                                entry.pid = current_line_prev_pid;
                                // console.log(`Updated comm/pid for existing TID ${current_line_prev_tid} to ${current_line_prev_comm}/${current_line_prev_pid} (pid==tid)`);
                            }
                            // If it's not a pid==tid case, we don't overwrite the comm, assuming the existing one
                            // (potentially set by a prior pid==tid or the first encounter) is preferred for that PID.
                            // We also assume the PID for a given TID doesn't change.
                        } else {
                            // No entry for this TID yet, add it.
                            comm_pid_tid_list.push({
                                comm: current_line_prev_comm,
                                pid: current_line_prev_pid,
                                tid: current_line_prev_tid
                            });
                            // console.log(`Added new entry for TID ${current_line_prev_tid}: ${current_line_prev_comm}/${current_line_prev_pid}`);
                        }

                        // Continue with existing logic for graph nodes and links
                        const s_comm = match[s_comm_idx];
                        const s_tid = match[s_tid_idx];
                        const t_comm = match[t_comm_idx];
                        const t_tid = match[t_tid_idx];

                        const sourceId = `${s_comm}/${s_tid}`; // Graph node ID uses comm/tid
                        const targetId = `${t_comm}/${t_tid}`; // Graph node ID uses comm/tid

                        if (sourceId === targetId) continue;

                        // In graph node objects, 'pid' field actually stores the TID part of the node ID.
                        if (!nodeMap.has(sourceId)) nodeMap.set(sourceId, { id: sourceId, comm: s_comm, pid: s_tid });
                        if (!nodeMap.has(targetId)) nodeMap.set(targetId, { id: targetId, comm: t_comm, pid: t_tid });

                        const linkKey = `${sourceId}->${targetId}`;

                        if (linkMap.has(linkKey)) {
                            linkMap.get(linkKey).weight++;
                        } else {
                            linkMap.set(linkKey, {
                                source: sourceId,
                                target: targetId,
                                weight: 1
                            });
                        }
                    }
                }

                console.log(`Parsed ${nodeMap.size} nodes and ${linkMap.size} links`);
                console.log("comm_pid_tid_list content:", JSON.stringify(comm_pid_tid_list.slice(0, 20), null, 2)); // Log first 20 entries
                if(comm_pid_tid_list.length > 20) console.log(`(Plus ${comm_pid_tid_list.length - 20} more entries in comm_pid_tid_list)`);
                return {
                    nodes: Array.from(nodeMap.values()),
                    links: Array.from(linkMap.values())
                };
            }

            function buildUndirectedGraph({nodes, links}) {
                const undirectedLinkMap = new Map();
                
                links.forEach(link => {
                    const nodeIds = [link.source, link.target].sort();
                    const undirectedKey = `${nodeIds[0]}->${nodeIds[1]}`;
                    
                    if (undirectedLinkMap.has(undirectedKey)) {
                        undirectedLinkMap.get(undirectedKey).weight += link.weight;
                    } else {
                        undirectedLinkMap.set(undirectedKey, {
                            source: nodeIds[0],
                            target: nodeIds[1],
                            weight: link.weight,
                            originalLinks: [link]
                        });
                    }
                });
                
                console.log(`Built undirected graph with ${nodes.length} nodes and ${undirectedLinkMap.size} links`);
                return {
                    nodes: [...nodes],
                    links: Array.from(undirectedLinkMap.values())
                };
            }

            function drawGraph(customData = null) {
                const isDirected = graphDirectionSelect.value === 'directed';
                const searchTerm = nodeSearchInput.value.trim().toLowerCase();
                const threshold = +weightThresholdInput.value;
                let nodes, links;
                let highlightMode = false;
                let bfsLayoutInfo = null; // To store BFS source and depths

                if (customData && customData.isBfsSubgraph) {
                    nodes = customData.nodes;
                    links = customData.links;
                    bfsLayoutInfo = customData.bfsLayoutInfo; // { sourceNodeId: '...', nodeDepths: Map(...) }
                    highlightMode = true; // Or a specific mode for BFS layout
                    console.log('[drawGraph] BFS Subgraph mode:', bfsLayoutInfo, 'nodes:', nodes, 'links:', links);
                }
                else if (customData) { // Other custom data, if any (though currently only BFS uses it)
                    nodes = customData.nodes;
                    links = customData.links;
                    highlightMode = true;
                    console.log('[drawGraph] Generic customData mode: highlightMode=true, nodes:', nodes, 'links:', links);
                } else {
                    if (!fullGraphData.nodes || fullGraphData.nodes.length === 0) {
                        console.log('No graph data available');
                        return;
                    }
                    console.log(`[drawGraph] Threshold: ${threshold}, Directed: ${isDirected}, Search: ${searchTerm || 'none'}`);
                    const baseGraphData = isDirected ? fullGraphData : undirectedGraphData;
                    ({ nodes, links } = baseGraphData);
                    if (searchTerm) {
                        const matchedNodes = nodes.filter(node => {
                            const match = node.id.toLowerCase().includes(searchTerm) || 
                                (node.comm && node.comm.toLowerCase().includes(searchTerm)) ||
                                (node.pid && node.pid.toLowerCase().includes(searchTerm));
                            return match;
                        });
                        if (matchedNodes.length === 0) {
                            nodes = [];
                            links = [];
                        } else {
                            const matchedNodeIds = new Set(matchedNodes.map(node => node.id));
                            links = links.filter(link => matchedNodeIds.has(link.source) || matchedNodeIds.has(link.target));
                            const nodesInLinks = new Set([
                                ...links.map(link => link.source),
                                ...links.map(link => link.target)
                            ]);
                            nodes = nodes.filter(node => nodesInLinks.has(node.id));
                        }
                    }
                    // 只在全图视图下做权重过滤
                    links = links.filter(link => link.weight >= threshold).sort((a, b) => b.weight - a.weight);
                    console.log(`[drawGraph] 全图模式: nodes:`, nodes, 'links:', links);
                }
                console.log(`[drawGraph] highlightMode=${highlightMode}, nodes.length=${nodes.length}, links.length=${links.length}`);

                // If drawGraph is called for a general view (not during an active highlight that sets fx/fy),
                // ensure all nodes are released from any prior fixed positions.
                // currentHighlightedNode is null when deselecting or resetting.
                // Note: highlightNodeConnections also clears fx/fy from simulation.nodes()
                // before setting new ones, so this primarily covers the reset path and ensures
                // the base node objects used by drawGraph are clean.
                if (!currentHighlightedNode) {
                    // Create a new array of node objects if nodes are just references, to avoid modifying source data cache directly,
                    // OR ensure that fx/fy are properties solely managed by the simulation instances.
                    // Given D3's behavior, fx/fy are often added to the original objects.
                    // So, it's better to nullify them on the 'nodes' array that will be used.
                    // This 'nodes' array is a fresh copy or filtered list at this point.
                    const allNodesToClear = simulation ? simulation.nodes() : (isDirected ? fullGraphData.nodes : undirectedGraphData.nodes);
                    allNodesToClear.forEach(n => {
                        n.fx = null;
                        n.fy = null;
                    });
                    // If 'nodes' is a filtered subset, ensure those are also cleared.
                    // This might be redundant if 'allNodesToClear' covers them, but safer.
                    nodes.forEach(n => { // 'nodes' is the array that will be passed to the new simulation
                        n.fx = null;
                        n.fy = null;
                    });
                }
                
                if (searchTerm) {
                    const matchedNodes = nodes.filter(node => {
                        const match = node.id.toLowerCase().includes(searchTerm) || 
                            (node.comm && node.comm.toLowerCase().includes(searchTerm)) ||
                            (node.pid && node.pid.toLowerCase().includes(searchTerm));
                        console.log(`Node ${node.id}: ${match ? 'MATCH' : 'NO MATCH'}`);
                        return match;
                    });
                    
                    console.log(`Found ${matchedNodes.length} matched nodes`);
                    
                    if (matchedNodes.length === 0) {
                        console.log('No nodes matched search term');
                        nodes = [];
                        links = [];
                    } else {
                        const matchedNodeIds = new Set(matchedNodes.map(node => node.id));
                        
                        links = links.filter(link => {
                            const match = matchedNodeIds.has(link.source) || matchedNodeIds.has(link.target);
                            console.log(`Link ${link.source} -> ${link.target}: ${match ? 'MATCH' : 'NO MATCH'}`);
                            return match;
                        });
                        
                        const nodesInLinks = new Set([
                            ...links.map(link => link.source),
                            ...links.map(link => link.target)
                        ]);
                        
                        nodes = nodes.filter(node => nodesInLinks.has(node.id));
                        
                        console.log(`Filtered to ${nodes.length} nodes and ${links.length} links after search`);
                    }
                }

                const filteredLinks = links
                    .filter(link => {
                        const match = link.weight >= threshold;
                        console.log(`Link ${link.source} -> ${link.target} (weight ${link.weight}): ${match ? 'PASS' : 'FILTERED'}`);
                        return match;
                    })
                    .sort((a, b) => b.weight - a.weight);

                console.log(`After weight threshold filter: ${filteredLinks.length} links`);
                
                // 调试输出过滤后的边数据
                console.log('Filtered links:', filteredLinks);

                const fullNodeLookup = new Map();
                fullGraphData.nodes.forEach(node => {
                    fullNodeLookup.set(node.id, {
                        id: node.id,
                        comm: node.comm || node.id.split('/')[0],
                        pid: node.pid || node.id.split('/')[1]
                    });
                });

                console.log(`Full node lookup created with ${fullNodeLookup.size} entries`);

                // 更新表格
                linksTableBody.innerHTML = '';

                if (filteredLinks.length === 0) {
                    console.log('No links to display in table');
                    const row = linksTableBody.insertRow();
                    const cell = row.insertCell();
                    cell.colSpan = 3;
                    cell.textContent = 'No links meet the current threshold.';
                    cell.className = 'px-3 py-2 text-center';
                } else {
                    console.log(`Populating table with ${filteredLinks.length} links`);
                    filteredLinks.forEach(link => {
                        // 确保link.source和link.target是字符串ID
                        const sourceId = typeof link.source === 'object' ? link.source.id : link.source;
                        const targetId = typeof link.target === 'object' ? link.target.id : link.target;
                        
                        const sourceNode = fullNodeLookup.get(sourceId);
                        const targetNode = fullNodeLookup.get(targetId);
                        
                        console.log(`Table row: ${sourceId} (${sourceNode ? sourceNode.comm : 'unknown'}) -> ${targetId} (${targetNode ? targetNode.comm : 'unknown'})`);
                        
                        // 额外调试：如果节点未找到，输出更多信息
                        if (!sourceNode) {
                            console.warn(`Source node not found for ID: ${sourceId}`, link);
                        }
                        if (!targetNode) {
                            console.warn(`Target node not found for ID: ${targetId}`, link);
                        }

                        const row = linksTableBody.insertRow();
                        row.className = 'bg-white border-b hover:bg-gray-50 transition-colors cursor-pointer'; // Added cursor-pointer
                        row.setAttribute('data-source-id', sourceId);
                        row.setAttribute('data-target-id', targetId);
                        row.setAttribute('data-weight', link.weight);


                        const cellNodeA = row.insertCell();
                        cellNodeA.innerHTML = sourceNode ? `<span class="task-link" data-node-id="${sourceId}">${sourceNode.comm}/${sourceNode.pid}</span>` : sourceId;
                        cellNodeA.className = 'px-3 py-2 font-medium text-gray-900 whitespace-nowrap';

                        const cellNodeB = row.insertCell();
                        cellNodeB.innerHTML = targetNode ? `<span class="task-link" data-node-id="${targetId}">${targetNode.comm}/${targetNode.pid}</span>` : targetId;
                        cellNodeB.className = 'px-3 py-2';

                        const cellSwitches = row.insertCell();
                        // Wrap weight in a span for specific click targeting
                        cellSwitches.innerHTML = `<span class="switches-value">${link.weight}</span>`;
                        cellSwitches.className = 'px-3 py-2 font-semibold text-indigo-600 text-right';
                    });

                    // 只保留 .task-link 的 click 事件
                    document.querySelectorAll('.task-link').forEach(link => {
                        link.addEventListener('click', (e) => {
                            e.stopPropagation(); // 防止冒泡
                            const nodeId = e.currentTarget.getAttribute('data-node-id');
                            highlightNodeConnections(nodeId);
                        });
                    });
                }

                // 图形渲染代码
                const container = document.getElementById('graph-container');
                const svg = d3.select("#graph-svg");

                // Store last transform if available
                // Check if svg.node() exists and is zoomable before getting transform
                if (svg.node() && typeof d3.zoomTransform === 'function' && svg.node().__zoom !== undefined && svg.node().__zoom !== d3.zoomIdentity) {
                     if (g) { // Ensure global g was previously defined (e.g. from a previous draw)
                        lastZoomTransform = d3.zoomTransform(svg.node());
                     }
                }


                svg.selectAll("*").remove(); // This removes 'g' as well if it was part of svg's children

                // Update displayed node and edge counts based on the data *before* simulation
                // These are the nodes and links that will be attempted to be rendered.
                filteredNodesValEl.textContent = nodes.length.toLocaleString();
                filteredEdgesValEl.textContent = filteredLinks.length.toLocaleString();
                const filteredSwitchesCount = filteredLinks.reduce((sum, link) => sum + link.weight, 0);
                filteredSwitchesValEl.textContent = filteredSwitchesCount.toLocaleString();

                // Cache the exact nodes and links being rendered for BFS in highlightNodeConnections
                currentlyDisplayedNodes = [...nodes]; // Store a copy
                currentlyDisplayedLinks = [...filteredLinks]; // Store a copy


                const width = container.clientWidth;
                const height = container.clientHeight;

                g = svg.append("g"); // Assign to the higher-scoped 'g'

                if (isDirected) {
                    svg.append("defs").append("marker")
                        .attr("id", "arrowhead")
                        // viewBox="0 0 <marker-length> <marker-height>"
                        .attr("viewBox", "0 0 5 3.5") // Adjusted viewBox for a 5x3.5 marker
                        // refX is distance from node center to the marker's reference point.
                        // Node radius is 8. Path tip is at x=5. refX=4 means (4,1.75) of marker is at node center.
                        // Tip (5,1.75) is 1px past node center.
                        .attr("refX", 4)
                        .attr("refY", 1.75) // Mid-point of marker height 3.5
                        .attr("markerWidth", 5) // Visual width of the marker
                        .attr("markerHeight", 3.5)  // Visual height of the marker
                        .attr("orient", "auto")
                        .append("path")
                        // Path for a 5x3.5 arrowhead: M0,0 L5,1.75 L0,3.5
                        .attr("d", "M 0 0 L 5 1.75 L 0 3.5 z")
                        .attr("class", "arrowhead");
                }

                // 确保links数据格式正确
                const formattedLinks = filteredLinks.map(link => ({
                    ...link,
                    source: typeof link.source === 'object' ? link.source.id : link.source,
                    target: typeof link.target === 'object' ? link.target.id : link.target
                }));

                simulation = d3.forceSimulation(nodes)
                    .force("link", d3.forceLink(formattedLinks).id(d => d.id)

                        .strength(d => 0.08 * Math.sqrt(d.weight / (d3.max(formattedLinks, l => l.weight) || 1))) // Re-introduced dynamic link strength
                        )
                    .force("charge", d3.forceManyBody().strength(bfsLayoutInfo ? -100 : -500)) // Weaker charge for BFS to rely more on fx/fy
                    .force("center", bfsLayoutInfo ? null : d3.forceCenter(width / 2, height / 2)) // No centering force for BFS
                    .force("collide", d3.forceCollide().radius(bfsLayoutInfo ? 30 : 22).strength(0.7)); // Slightly larger collision for BFS if needed

                if (bfsLayoutInfo) {
                    // Apply hierarchical layout for BFS subgraph
                    const { sourceNodeId, nodeDepths } = bfsLayoutInfo;
                    const levels = new Map(); // Map<depth, Array<nodeId>>
                    let maxDepth = 0;

                    nodes.forEach(node => {
                        const depth = nodeDepths.get(node.id);
                        if (depth === undefined) {
                            console.warn(`Node ${node.id} in BFS subgraph but missing from depth map. Placing at depth 0.`);
                            // This case should ideally not happen if data is consistent
                            if (!levels.has(0)) levels.set(0, []);
                            levels.get(0).push(node.id);
                            node.depth = 0; // Assign depth for layout
                        } else {
                            if (!levels.has(depth)) levels.set(depth, []);
                            levels.get(depth).push(node.id);
                            if (depth > maxDepth) maxDepth = depth;
                            node.depth = depth; // Assign depth for layout
                        }
                    });

                    const layerHeight = Math.max(100, (height - 100) / (maxDepth + 1)); // Adjusted layer height, ensure min
                    const PADDING_X = 50; // Padding from the sides of the SVG
                    const availableWidth = width - 2 * PADDING_X;
                    const MAX_NODES_PER_SUB_ROW = 8; // Max nodes before splitting a layer into sub-rows
                    const SUB_ROW_OFFSET_Y = 60; // Vertical offset for the second sub-row

                    levels.forEach((nodeIdsInLevel, depth) => {
                        const base_y = 50 + depth * (layerHeight + SUB_ROW_OFFSET_Y / 2); // Adjust layerHeight to account for potential subrows
                        const numNodesInLevel = nodeIdsInLevel.length;

                        // Sort nodes in the level by weight if splitting is needed.
                        if (numNodesInLevel > MAX_NODES_PER_SUB_ROW && numNodesInLevel > 1 && depth > 0) {
                            const nodesWithWeights = nodeIdsInLevel.map(nodeId => {
                                let sortWeight = 0;
                                const nodeDepth = nodeDepths.get(nodeId); // Actual depth of this node

                                // Sum weights of incoming links from the previous layer
                                links.forEach(link => { // 'links' here are the links of the BFS subgraph
                                    const sourceId = typeof link.source === 'object' ? link.source.id : link.source;
                                    const targetId = typeof link.target === 'object' ? link.target.id : link.target;
                                    if (targetId === nodeId) {
                                        const sourceDepth = nodeDepths.get(sourceId);
                                        if (sourceDepth === nodeDepth - 1) {
                                            sortWeight += link.weight;
                                        }
                                    }
                                });
                                return { id: nodeId, weight: sortWeight };
                            });

                            // Sort by weight (descending), then by ID (ascending) for tie-breaking
                            nodesWithWeights.sort((a, b) => {
                                if (b.weight !== a.weight) {
                                    return b.weight - a.weight;
                                }
                                return a.id.localeCompare(b.id);
                            });
                            nodeIdsInLevel = nodesWithWeights.map(nw => nw.id); // Update nodeIdsInLevel to be sorted
                        } else if (numNodesInLevel > 1) {
                            // Default sort by ID if not splitting by weight (e.g. depth 0 or not enough nodes for weighted split)
                            nodeIdsInLevel.sort();
                        }


                        const subRows = [];
                        if (numNodesInLevel > MAX_NODES_PER_SUB_ROW && numNodesInLevel > 1) {
                            const splitPoint = Math.ceil(numNodesInLevel / 2);
                            subRows.push(nodeIdsInLevel.slice(0, splitPoint));
                            subRows.push(nodeIdsInLevel.slice(splitPoint));
                        } else {
                            subRows.push(nodeIdsInLevel);
                        }

                        subRows.forEach((nodesInSubRow, subRowIndex) => {
                            const current_y = base_y + subRowIndex * SUB_ROW_OFFSET_Y;
                            const numNodesInSubRow = nodesInSubRow.length;

                            let estimatedMaxNodeWidth = 150;
                            if (numNodesInSubRow > 0) {
                                const sampleNode = nodes.find(n => n.id === nodesInSubRow[0]);
                                if (sampleNode && sampleNode.comm && sampleNode.pid) {
                                    estimatedMaxNodeWidth = Math.max(120, (sampleNode.comm.length + sampleNode.pid.length + 5) * 7); // Adjusted estimation
                                }
                            }
                            const nodeSpacingX = Math.max(estimatedMaxNodeWidth + 30, availableWidth / Math.max(1, numNodesInSubRow));

                            nodesInSubRow.forEach((nodeId, index) => {
                                const node = nodes.find(n => n.id === nodeId);
                                if (node) {
                                    const totalWidthOfNodesInSubRow = numNodesInSubRow * nodeSpacingX;
                                    const startX = PADDING_X + (availableWidth - totalWidthOfNodesInSubRow + nodeSpacingX) / 2;
                                    node.fx = startX + index * nodeSpacingX;
                                    node.fy = current_y;
                                }
                            });
                        });
                    });
                     // For BFS, stop simulation quickly after initial positioning if nodes have fx/fy
                    simulation.alpha(0.3).restart(); // Give it a bit of alpha to settle links
                    setTimeout(() => simulation.stop(), 500); // Stop after a short period

                } else {
                     // For non-BFS, ensure fx/fy are cleared if they were set by a previous BFS view
                     nodes.forEach(n => {
                        // n.fx = null; // This was part of a general reset logic earlier,
                        // n.fy = null; // ensure it's consistent with how drag behavior sets/unsets fx/fy
                                     // The drag behavior already nulls fx/fy on dragend for non-BFS.
                                     // And resetGraphFilter also clears fx/fy.
                     });
                }


                // Draw nodes first so links (and arrowheads) appear on top.
                const nodeGroup = g.append("g")
                    .selectAll("g")
                    .data(nodes)
                    .join("g")
                    .attr("class", "node");

                nodeGroup.append("circle")
                    .attr("r", highlightMode ? 12 : 8)
                    .attr("fill", highlightMode ? "#ff3b3b" : "#4f46e5")
                    .attr("stroke", highlightMode ? "#ffd600" : "#fff")
                    .attr("stroke-width", highlightMode ? 5 : 1.5);

                nodeGroup.append("text")
                    .text(d => `${d.comm}/${d.pid}`)
                    .attr("font-size", highlightMode ? (bfsLayoutInfo ? "10px" : "16px") : "12px") // Smaller font for BFS to fit more
                    .attr("font-family", "monospace")
                    .attr("fill", highlightMode ? (bfsLayoutInfo ? "#1e3a8a" : "#d32f2f") : "#333")
                    .attr("font-weight", highlightMode ? "bold" : "normal")
                    .style("pointer-events", "none")
                    .style("display", "block") // Default display, will be managed below
                    .each(function(d) { // Adjust text position based on mode
                        if (bfsLayoutInfo) {
                            // For BFS Subgraph: Text above the node
                            // Node circle radius in highlightMode (which bfsLayoutInfo implies) is 12.
                            // Font size in this mode is 10px.
                            // A y of -18 should place baseline of 10px font comfortably above a circle of radius 12.
                            d3.select(this)
                                .attr("x", 0) // Centered horizontally
                                .attr("y", -18) // Position text baseline above the node circle
                                .attr("text-anchor", "middle");
                        } else {
                            // For full graph or other modes
                            d3.select(this)
                                .attr("x", 16) // Original position for non-BFS
                                .attr("y", 6)
                                .attr("text-anchor", "start");
                        }
                    });

                if (!bfsLayoutInfo) { // Only add mouse events and drag if not in BFS layout mode
                    nodeGroup.on("mouseover", function(event, d) {
                            d3.select(this).select('text').style('display', 'block');

                            // d.id is "comm/tid", d.pid is the "tid" part.
                            const selectedNodeTid = d.pid; // This is the TID of the hovered graph node.
                            const pidInfoEntry = comm_pid_tid_list.find(entry => entry.tid === selectedNodeTid);

                            let tooltipHtml = `TID: ${selectedNodeTid}<br>TID Name: ${d.comm}`;
                            if (pidInfoEntry) {
                                tooltipHtml += `<br>---<br>PID: ${pidInfoEntry.pid}<br>PID Name: ${pidInfoEntry.comm}`;
                            } else {
                                tooltipHtml += `<br>---<br>(PID info not found for this TID)`;
                            }
                            tooltip.style("opacity", 1).html(tooltipHtml);
                        })
                        .on("mousemove", (event) => {
                            tooltip.style("left", (event.pageX + 15) + "px")
                                   .style("top", (event.pageY - 28) + "px");
                        })
                        .on("mouseout", function() {
                            // In normal mode, hide text on mouseout if it wasn't a highlighted node
                            // For simplicity here, we assume drawGraph sets text display for non-BFS mode
                            // or rely on a general rule (e.g. only show on hover for non-highlighted)
                            // The current code shows it if highlightMode is true, which is fine.
                            // If not highlightMode, it's shown by default.
                            // Let's stick to: if not highlightMode, text is generally visible or managed by a global show/hide toggle
                            // For BFS mode, text is always visible.
                            // The default .style("display", "block") for text ensures it's visible
                            // unless highlightNodeConnections or other logic explicitly hides it for non-BFS.
                            // The original code had text display:none then mouseover made it block.
                            // Now for non-BFS, it's always block.
                            // Let's revert to original behavior for non-BFS text.
                            if (!highlightMode) d3.select(this).select('text').style('display', 'none');
                            tooltip.style("opacity", 0);
                        })
                        .on("click", function(event, d) {
                            highlightNodeConnections(d.id);
                        });

                    const drag = d3.drag()
                        .on("start", (event, d) => {
                            if (!event.active) simulation.alphaTarget(0.3).restart();
                            d.fx = d.x;
                            d.fy = d.y;
                        })
                        .on("drag", (event, d) => {
                            d.fx = event.x;
                            d.fy = event.y;
                        })
                        .on("end", (event, d) => {
                            if (!event.active) simulation.alphaTarget(0);
                            // For non-BFS mode, allow nodes to be unpinned.
                            // For BFS mode, positions are fixed by the layout.
                            d.fx = null;
                            d.fy = null;
                        });
                    nodeGroup.call(drag);
                } else { // BFS Layout:
                    // Ensure text is always visible for BFS nodes
                    nodeGroup.selectAll('text').style('display', 'block');

                    // Click on a node in BFS view should still allow deselecting/selecting another
                    nodeGroup.on("click", function(event, d) {
                        // If drag event happened, d3 might stop propagation of click.
                        // Check if it was a drag, if so, maybe don't trigger click?
                        // For now, standard click behavior.
                        if (event.defaultPrevented) return; // Drag might prevent default click
                        highlightNodeConnections(d.id);
                    });

                    // Enable dragging for BFS nodes, but they stick where dragged
                    const bfsDrag = d3.drag()
                        .on("start", function(event, d) {
                            if (!event.active && simulation) simulation.alphaTarget(0.1).restart(); // Gentle reheat
                            d.fx = d.x; // Capture current position to start drag from
                            d.fy = d.y;
                            // No need to add class or change appearance on drag start for BFS fixed nodes unless desired
                        })
                        .on("drag", function(event, d) {
                            d.fx = event.x;
                            d.fy = event.y;
                            // Update position of the group as it's dragged
                            d3.select(this).attr("transform", `translate(${d.fx},${d.fy})`);
                        })
                        .on("end", function(event, d) {
                            if (!event.active && simulation) simulation.alphaTarget(0);
                            // IMPORTANT: For BFS mode, d.fx and d.fy are NOT nulled out.
                            // The node stays where it was dragged.
                        });
                    nodeGroup.call(bfsDrag);
                }


                // Now, draw links so they appear on top of nodes.
                const linkGroup = g.append("g")
                    .selectAll("g")
                    .data(formattedLinks)
                    .join("g")
                    .attr("class", "link-group");

                const linkLine = linkGroup.append("line")
                    .attr("stroke", highlightMode ? "#ffd600" : "#999")
                    .attr("stroke-opacity", highlightMode ? 1 : 0.6)
                    .attr("stroke-width", d => highlightMode ? (bfsLayoutInfo ? createThicknessScale(formattedLinks, 1.5, 10)(d.weight) : 6) : createThicknessScale(formattedLinks, 0.8, 10)(d.weight));

                if (isDirected) {
                    linkLine.attr("marker-end", "url(#arrowhead)");
                } else {
                    linkLine.attr("marker-end", null); // Explicitly remove marker if not directed
                }

                linkGroup.append("text")
                    .text(d => d.weight)
                    .attr("font-size", "10px")
                    .attr("font-family", "sans-serif")
                    .attr("fill", "#333")
                    .attr("stroke", "white")
                    .attr("stroke-width", 0.4)
                    .attr("paint-order", "stroke")
                    .style("display", "none")
                    .style("pointer-events", "none");

                linkGroup
                    .on("mouseover", function(event, d) {
                        d3.select(this).select('text').style('display', 'block');
                        tooltip.style("opacity", 1).html(`切换次数: ${d.weight}`);
                    })
                    .on("mousemove", (event) => {
                        tooltip.style("left", (event.pageX + 15) + "px")
                               .style("top", (event.pageY - 28) + "px");
                    })
                    .on("mouseout", function() {
                        d3.select(this).select('text').style('display', 'none');
                        tooltip.style("opacity", 0);
                    });


                const zoom = d3.zoom()
                    .scaleExtent([0.1, 10])
                    .on("zoom", (event) => {
                        g.attr("transform", event.transform);
                    });

                svg.call(zoom);

                // Apply the stored transform
                if (lastZoomTransform) {
                    // svg.call(zoom.transform, lastZoomTransform); //This is the correct way
                    // For older d3, or if 'g' is the transformed element directly by zoom event:
                     g.attr('transform', lastZoomTransform.toString());
                     // To make the zoom behavior aware of this new transform:
                     d3.select(svg.node()).call(zoom.transform, lastZoomTransform);

                }


                simulation.on("tick", () => {
                    linkGroup.select("line")
                        .attr("x1", d => d.source.x)
                        .attr("y1", d => d.source.y)
                        .attr("x2", d => d.target.x)
                        .attr("y2", d => d.target.y);

                    linkGroup.select("text")
                        .attr("x", d => (d.source.x + d.target.x) / 2)
                        .attr("y", d => (d.source.y + d.target.y) / 2);

                    nodeGroup.attr("transform", d => `translate(${d.x},${d.y})`);
                });
                
                console.log('Graph drawing completed');
                
                // 只在全图模式下自动高亮
                if (!customData && currentHighlightedNode) {
                    console.log('[drawGraph] 全图模式下自动高亮 currentHighlightedNode:', currentHighlightedNode);
                    highlightNodeConnections(currentHighlightedNode);
                }
            }

            function highlightNodeConnections(nodeId) {
                console.log('[highlightNodeConnections] 选中节点:', nodeId);
                if (highlightedLinkFromTable) {
                    highlightedLinkFromTable = null;
                    document.querySelectorAll('#links-table-body tr').forEach(row => row.classList.remove('bg-indigo-100'));
                }
                if (bfsActiveNode === nodeId) {
                    bfsActiveNode = null;
                    currentHighlightedNode = null;
                    connectedNodes.clear();
                    connectedLinks.clear();
                    document.querySelectorAll('.task-link').forEach(link => {
                        link.classList.remove('font-bold', 'text-indigo-700');
                    });
                    console.log('[highlightNodeConnections] 取消高亮，恢复全图');
                    drawGraph();
                    return;
                }
                bfsActiveNode = nodeId;
                currentHighlightedNode = nodeId;
                const maxDepth = +bfsDepthSelect.value;
                const isDirected = graphDirectionSelect.value === 'directed';
                const currentWeightThreshold = +weightThresholdInput.value;

                const baseGraphData = isDirected ? fullGraphData : undirectedGraphData;

                // 1. Filter graph by weightThreshold
                const thresholdFilteredLinks = baseGraphData.links.filter(link => link.weight >= currentWeightThreshold);
                const nodesInThresholdedGraphIds = new Set();
                thresholdFilteredLinks.forEach(link => {
                    nodesInThresholdedGraphIds.add(typeof link.source === 'object' ? link.source.id : link.source);
                    nodesInThresholdedGraphIds.add(typeof link.target === 'object' ? link.target.id : link.target);
                });
                // Ensure the starting node for BFS is part of the thresholded graph, otherwise, no BFS is possible.
                if (!nodesInThresholdedGraphIds.has(nodeId)) {
                    console.log(`[highlightNodeConnections] Start node ${nodeId} is not present in the graph after weight threshold ${currentWeightThreshold}. Displaying empty subgraph.`);
                    drawGraph({ isBfsSubgraph: true, nodes: [], links: [], bfsLayoutInfo: { sourceNodeId: nodeId, nodeDepths: new Map() } });
                    // Update counts for empty graph
                    filteredNodesValEl.textContent = '0';
                    filteredEdgesValEl.textContent = '0';
                    filteredSwitchesValEl.textContent = '0';
                     // Clear any existing table highlights for task links if the source node isn't even in the thresholded graph
                    document.querySelectorAll('.task-link').forEach(link => {
                        link.classList.remove('font-bold', 'text-indigo-700');
                    });
                    return;
                }

                const thresholdFilteredNodes = baseGraphData.nodes.filter(node => nodesInThresholdedGraphIds.has(node.id));

                // 2. Perform BFS on the threshold-filtered graph
                connectedNodes.clear(); // Clear from previous selections
                connectedLinks.clear(); // Clear from previous selections
                const queue = [{ id: nodeId, depth: 0 }];
                connectedNodes.set(nodeId, 0);
                let head = 0;

                while (head < queue.length) {
                    const { id: currentId, depth: currentDepth } = queue[head++];
                    if (currentDepth >= maxDepth) continue;

                    thresholdFilteredLinks.forEach(link => {
                        const linkSourceId = typeof link.source === 'object' ? link.source.id : link.source;
                        const linkTargetId = typeof link.target === 'object' ? link.target.id : link.target;
                        let neighborId = null;

                        if (linkSourceId === currentId && nodesInThresholdedGraphIds.has(linkTargetId)) { // Check if target is in thresholded graph
                            neighborId = linkTargetId;
                        } else if (!isDirected && linkTargetId === currentId && nodesInThresholdedGraphIds.has(linkSourceId)) { // Check if source is in thresholded graph
                            neighborId = linkSourceId;
                        }

                        if (neighborId) {
                            if (!connectedNodes.has(neighborId) || connectedNodes.get(neighborId) > currentDepth + 1) {
                                connectedNodes.set(neighborId, currentDepth + 1);
                                queue.push({ id: neighborId, depth: currentDepth + 1 });
                                // Links are added based on traversal path
                                let key;
                                if (isDirected) {
                                    key = `${currentId}->${neighborId}`;
                                } else {
                                    const ids = [currentId, neighborId].sort();
                                    key = `${ids[0]}->${ids[1]}`;
                                }
                                // We need to ensure this key corresponds to an actual link in thresholdFilteredLinks
                                // This check is implicitly handled when constructing bfsLinks later using connectedLinks
                                connectedLinks.add(key);
                            }
                        }
                    });
                }

                // 3. Construct the subgraph from BFS results on the threshold-filtered graph
                const bfsNodeIds = new Set(connectedNodes.keys());
                const bfsNodes = thresholdFilteredNodes.filter(n => bfsNodeIds.has(n.id));

                // Filter thresholdFilteredLinks to get all links where both source and target nodes are in the bfsNodeIds set.
                // This ensures all connections between the reachable nodes are shown, not just BFS tree edges.
                const bfsLinks = thresholdFilteredLinks.filter(link => {
                    const s = typeof link.source === 'object' ? link.source.id : link.source;
                    const t = typeof link.target === 'object' ? link.target.id : link.target;
                    return bfsNodeIds.has(s) && bfsNodeIds.has(t);
                });

                console.log(`[highlightNodeConnections] BFS on thresholded graph (showing all links between reachable nodes): Nodes=${bfsNodes.length}, Links=${bfsLinks.length}`);

                const bfsDisplayData = {
                    isBfsSubgraph: true,
                    nodes: bfsNodes,
                    links: bfsLinks,
                    bfsLayoutInfo: {
                        sourceNodeId: nodeId,
                        nodeDepths: connectedNodes // This map from BFS (nodeId -> depth)
                    }
                };
                // 高亮显示子图
                drawGraph(bfsDisplayData);

                // 表格高亮
                document.querySelectorAll('.task-link').forEach(link => {
                    if (link.getAttribute('data-node-id') === nodeId) {
                        link.classList.add('font-bold', 'text-indigo-700');
                    } else {
                        link.classList.remove('font-bold', 'text-indigo-700');
                    }
                });
                // 更新计数
                filteredNodesValEl.textContent = bfsNodes.length.toLocaleString();
                filteredEdgesValEl.textContent = bfsLinks.length.toLocaleString();
                filteredSwitchesValEl.textContent = bfsLinks.reduce((sum, l) => sum + l.weight, 0).toLocaleString();
            }

            function resetGraphFilter() {
                console.log('Resetting graph filter');

                // Clear single link highlight state from table
                highlightedLinkFromTable = null;
                document.querySelectorAll('#links-table-body tr').forEach(row => row.classList.remove('bg-indigo-100'));
                // updateGraphForTableLinkHighlight(); // Call to reset styles if it was active
                // No, drawGraph will reset styles.

                currentHighlightedNode = null; // Clear any BFS node highlight state
                connectedNodes.clear();
                connectedLinks.clear();
                // Clear any node selection styling from table cells (task-links)
                 document.querySelectorAll('#links-table-body .task-link').forEach(link => {
                    link.classList.remove('font-bold', 'text-indigo-700');
                });


                // Reset input fields to defaults if desired, or simply redraw
                // weightThresholdInput.value = "50"; // Or initial default
                // nodeSearchInput.value = "";
                // graphDirectionSelect.value = "undirected"; // Or initial default
                // bfsDepthSelect.value = "5"; // Or initial default

                // Redraw the graph with original filters/no filters.
                // This will also update displayedNodesCountEl and displayedEdgesCountEl.
                drawGraph();
                
                // The d3 selections for highlighting are reset within drawGraph or highlightNodeConnections(null)
                // If drawGraph() doesn't fully reset all visual states (e.g. table highlights), do it here:
                document.querySelectorAll('.task-link').forEach(link => {
                    link.classList.remove('font-bold', 'text-indigo-700');
                });
            }

            function debounce(func, delay) {
                let timeout;
                return function() {
                    const context = this;
                    const args = arguments;
                    clearTimeout(timeout);
                    timeout = setTimeout(() => func.apply(context, args), delay);
                };
            }

            // Fullscreen API handling
            function isFullscreenApiAvailable() {
                return document.fullscreenEnabled ||
                       document.mozFullScreenEnabled ||
                       document.webkitFullscreenEnabled ||
                       document.msFullscreenEnabled || false;
            }

            function toggleFullscreen() {
                const isCurrentlyFullscreen = document.fullscreenElement ||
                                            document.mozFullScreenElement ||
                                            document.webkitFullscreenElement ||
                                            document.msFullscreenElement;

                if (!isCurrentlyFullscreen) { // Not in fullscreen, try to enter
                    if (!isFullscreenApiAvailable()) {
                        console.warn("Fullscreen API is not available or not allowed in this context (e.g., missing iframe 'allowfullscreen' attribute).");
                        alert("Fullscreen mode is not available or not allowed in this environment."); // Optional: alert user
                        return;
                    }

                    if (graphContainer.requestFullscreen) {
                        graphContainer.requestFullscreen();
                    } else if (graphContainer.mozRequestFullScreen) { /* Firefox */
                        graphContainer.mozRequestFullScreen();
                    } else if (graphContainer.webkitRequestFullscreen) { /* Chrome, Safari & Opera */
                        graphContainer.webkitRequestFullscreen();
                    } else if (graphContainer.msRequestFullscreen) { /* IE/Edge */
                        graphContainer.msRequestFullscreen();
                    }
                } else { // In fullscreen, try to exit
                    if (document.exitFullscreen) {
                        document.exitFullscreen();
                    } else if (document.mozCancelFullScreen) { /* Firefox */
                        document.mozCancelFullScreen();
                    } else if (document.webkitExitFullscreen) { /* Chrome, Safari & Opera */
                        document.webkitExitFullscreen();
                    } else if (document.msExitFullscreen) { /* IE/Edge */
                        document.msExitFullscreen();
                    }
                }
            }

            fullscreenToggleBtn.addEventListener('click', toggleFullscreen);

            function updateFullscreenButton() {
                const isGraphFullscreen = document.fullscreenElement === graphContainer ||
                                       document.mozFullScreenElement === graphContainer ||
                                       document.webkitFullscreenElement === graphContainer ||
                                       document.msFullscreenElement === graphContainer;
                if (isGraphFullscreen) {
                    fullscreenToggleBtn.textContent = 'X'; // Exit fullscreen icon
                } else {
                    fullscreenToggleBtn.textContent = '[ ]'; // Enter fullscreen icon
                }
                return isGraphFullscreen;
            }

            function handleFullscreenChange() {
                const isGraphNowFullscreen = updateFullscreenButton();
                console.log("Fullscreen state changed. Graph is fullscreen:", isGraphNowFullscreen);

                // Trigger a redraw to adapt to new dimensions
                if (fullGraphData.nodes && fullGraphData.nodes.length > 0) {
                    setTimeout(() => {
                        // If drawGraph reinitializes simulation, that's fine.
                        // If it doesn't, we might need to update forces here.
                        // drawGraph() already recalculates width/height and re-centers.
                        drawGraph();

                        // Ensure simulation adapts if it's already running
                        if (simulation && simulation.nodes().length > 0) {
                             const newWidth = graphContainer.clientWidth;
                             const newHeight = graphContainer.clientHeight;
                             simulation.force("center", d3.forceCenter(newWidth / 2, newHeight / 2));
                             // simulation.alpha(0.3).restart(); // Reheat simulation may or may not be desired on every resize
                        }
                        console.log("Graph redraw triggered due to fullscreen change.");
                    }, 150); // Delay to allow DOM to settle
                }
            }

            document.addEventListener('fullscreenchange', handleFullscreenChange);
            document.addEventListener('mozfullscreenchange', handleFullscreenChange);
            document.addEventListener('webkitfullscreenchange', handleFullscreenChange);
            document.addEventListener('msfullscreenchange', handleFullscreenChange);

            // Initial button state update
            updateFullscreenButton();

            // --- Task 1: Edge Highlighting from Table Click ---
            // linksTableBody.addEventListener('click', function(event) {

            //     const clickedTaskLink = event.target.closest('.task-link');
            //     const clickedSwitchesValue = event.target.closest('.switches-value');
            //     const targetRow = event.target.closest('tr');

            //     if (!targetRow) return; // Clicked outside of any row context

            //     // Clear all previous table row highlights first.
            //     // This ensures that if a deselect happens, no rows remain highlighted from previous state.
            //     document.querySelectorAll('#links-table-body tr').forEach(row => row.classList.remove('bg-indigo-100'));

            //     if (clickedTaskLink) {
            //         const nodeId = clickedTaskLink.getAttribute('data-node-id');
            //         console.log(`Table Event: Task link clicked for node ID: ${nodeId}`);

            //         // If a single specific link was highlighted from table (not BFS), clear that visual state.
            //         // highlightNodeConnections will take over for BFS display.
            //         if (highlightedLinkFromTable) {
            //             updateGraphForTableLinkHighlight(true); // true to clear only, sets highlightedLinkFromTable = null
            //         }

            //         // Delegate all selection/deselection logic to highlightNodeConnections.
            //         // This function already handles toggling, setting currentHighlightedNode,
            //         // and updating task-link bolding.
            //         highlightNodeConnections(nodeId);

            //         // After highlightNodeConnections, currentHighlightedNode is either nodeId (if selected) or null (if deselected).
            //         // Re-apply highlight to the clicked row ONLY if the node ended up being selected.
            //         if (currentHighlightedNode === nodeId && targetRow) {
            //             targetRow.classList.add('bg-indigo-100');
            //         }
            //         // Note: The bolding of the .task-link text itself is handled within highlightNodeConnections.

            //     } else if (clickedSwitchesValue) {
            //         const sourceId = targetRow.getAttribute('data-source-id');
            //         const targetId = targetRow.getAttribute('data-target-id');
            //         const weight = targetRow.getAttribute('data-weight');

            //         if (!sourceId || !targetId) {
            //             console.warn("Row for switches click missing source/target ID.");
            //             return;
            //         }
            //         console.log(`Table Event: Switches value clicked for edge: ${sourceId} -> ${targetId}, Weight: ${weight}`);

            //         // If a BFS highlight is active, reset it before highlighting a single edge.
            //         if (currentHighlightedNode) {
            //             resetGraphFilter();
            //         }

            //         highlightedLinkFromTable = { sourceId, targetId, weight: parseInt(weight) };
            //         updateGraphForTableLinkHighlight(); // Apply single edge highlight styles in the graph.

            //         if (targetRow) { // Highlight the clicked row in the table.
            //             targetRow.classList.add('bg-indigo-100');
            //         }

            //     } else {
            //         // Clicked on a row but not on a specific interactive element (task-link or switches-value)
            //         console.log("Table Event: Clicked on table row padding or non-specific area.");
            //         // No action needed here, row highlights were already cleared.
            //     }
            // });

            function updateGraphForTableLinkHighlight(clearOnly = false) {
                if (!simulation || !simulation.nodes() || !g) {
                    console.warn("Simulation or graph group not ready for single link highlight/clear.");
                    return;
                }

                if (clearOnly || !highlightedLinkFromTable) {
                    // Reset styles for all links and nodes to their default appearance
                    g.selectAll('.link-group').each(function(d_link) {
                        const line = d3.select(this).select('line');
                        const text = d3.select(this).select('text');
                        // Use currentlyDisplayedLinks for the scale, as it reflects the main graph's links
                        const generalThicknessScale = createThicknessScale(currentlyDisplayedLinks || [], 0.8, 10);

                        line.attr('stroke', '#999')
                            .attr('stroke-opacity', 0.6)
                            .attr('stroke-width', generalThicknessScale(d_link.weight));

                        // Re-apply marker based on current graph direction state
                        if (graphDirectionSelect.value === 'directed') {
                            line.attr("marker-end", "url(#arrowhead)");
                        } else {
                            line.attr("marker-end", null);
                        }
                        text.style('display', 'none').style('font-weight', 'normal'); // Reset font weight
                    });

                    g.selectAll('.node').each(function(d_node) {
                        const circle = d3.select(this).select('circle');
                        const text = d3.select(this).select('text');

                        circle.attr('fill', '#4f46e5') // Default node color
                              .attr('r', 8) // Default radius
                              .classed('node-highlighted', false)
                              .classed('node-dimmed', false);
                        text.style('display', 'none').classed('highlighted-node-text', false);
                    });

                    if (clearOnly) {
                        highlightedLinkFromTable = null;
                        // Table row highlight is managed by the caller or resetGraphFilter
                    }
                    return;
                }

                // If we reach here, highlightedLinkFromTable is set and clearOnly is false.
                // Ensure currentHighlightedNode (BFS highlight) is cleared. This should ideally be done by the caller.
                if (currentHighlightedNode) {
                    console.warn("updateGraphForTableLinkHighlight (applying highlight) called while currentHighlightedNode is active. BFS highlight should be cleared by caller first.");
                    // For safety, clearing BFS fixed positions if any. Styles will be overridden below.

                    simulation.nodes().forEach(n => { n.fx = null; n.fy = null; });
                    currentHighlightedNode = null;
                    connectedNodes.clear();
                    connectedLinks.clear();

                     // A full drawGraph() might be better here to reset all node/link states before applying single link highlight.
                    // For now, we assume the caller (table click listener) has called resetGraphFilter if needed.
                }

                const { sourceId, targetId, weight } = highlightedLinkFromTable;

                g.selectAll('.link-group').each(function(d_link) {
                    const line = d3.select(this).select('line');
                    const text = d3.select(this).select('text');
                    const linkSourceId = typeof d_link.source === 'object' ? d_link.source.id : d_link.source;
                    const linkTargetId = typeof d_link.target === 'object' ? d_link.target.id : d_link.target;

                    if (linkSourceId === sourceId && linkTargetId === targetId) {
                        line.attr('stroke', '#1e40af') // Distinct highlight color (e.g., strong blue)
                            .attr('stroke-opacity', 1)
                            .attr('stroke-width', Math.max(createThicknessScale([d_link], 1.5, 10)(d_link.weight), 4)); // Make it noticeably thick
                        text.style('display', 'block').style('font-weight', 'bold');
                    } else {
                        line.attr('stroke', '#e5e7eb') // Dim color
                            .attr('stroke-opacity', 0.3)
                            .attr('stroke-width', 0.5);
                        text.style('display', 'none');
                    }
                });

                g.selectAll('.node').each(function(d_node) {
                    const circle = d3.select(this).select('circle');
                    const text = d3.select(this).select('text');
                    if (d_node.id === sourceId || d_node.id === targetId) {
                        circle.attr('fill', '#f59e0b') // Highlight color for connected nodes
                              .attr('r', 10);
                        text.style('display', 'block').classed('highlighted-node-text', true);
                    } else {
                        circle.attr('fill', '#d1d5db') // Dim color for other nodes
                              .attr('r', 5);
                        text.style('display', 'none').classed('highlighted-node-text', false);
                    }
                });
            }
            // --- End Task 1 ---
        });
    </script>
</body>
</html>    
